\chapter{Analysis}\label{chap:03-analysis}

In this chapter, we analyze the protocol and select the necessary subset needed for evaluation of a
pure \dotnet{} implementation. Afterwards, we design the architecture and outline the implementation
\todo{this should be expanded once the chapter is written}

\section{Protocol Features Selection}

The set of features to be implemented is guided by the goals we set in this thesis goals in the
introduction chapter. For the purpose of feature selection, we can rephrase subset of the original
goals into the following:

\todo{the goals below are a convenient rephrasing and can't be mapped 1-to-1 to the goals stated in
  the introduction, is that OK?}

\begin{enumerate}

  \item Support basic data transport, enabling some experimentation with QUIC as the transport for
    application layer protocols.

  \item Enable performance measurements that are representative of the potential full QUIC
    implementation.

\end{enumerate}

The first goal definitely requires full implementation of the multiplexed stream abstraction as
defined by the QUIC specification. It requires also implementing loss detection and recovery to
ensure that no data gets lost during the transport.

In order to get representative performance measurements, all performance affecting aspects of the
protocol should be implemented. The most important are packet protection and flow control because
they influence performance throughout the lifetime of the QUIC connection.

To summarize, the thesis should implement at least the following features:

\begin{itemize}

    \item Connection lifetime support (establishment, termination)

    \item Stream multiplexing

    \item Packet protection

    \item Loss detection and recovery

    \item Flow control

\end{itemize}

On the other hand, many QUIC features that react to one-time events can be disregarded, because
there either is no need for them in the evaluation environment, or they do not have relevant
performance or functional implications. In particular, implementation of the following features can
be avoided:

\begin{itemize}

    \item Connection migration, and therefore multiple Connection IDs support

    \item Complex (token-based) address validation

    \item Network path MTU detection

    \item Version negotiation

    \item 1-RTT key updates

    \item Advanced security measures (see Section 21 in transport specification~\cite{draft-ietf-quic-transport})

\end{itemize}

The rest of the features form a grey area which can be implemented fully, partially, or even not at
if convenient.

\section{Design Considerations}

Before we start the actual analysis, we will briefly outline the design principles used for the
actual design of the implementation and their rationale.

\subsection{Performance}

One of the key factors in the decision between managed \dotnet{} implementation of QUIC or using
external library like \libmsquic{} is performance. Therefore, the decisions made during the
implementation design should focus towards greater performance, possibly sacrificing maintainability
if the trade-off is justified.

As a general rule, the implementation will:

\begin{itemize}

    \litem{Avoid heap allocations} Although heap allocation is considered cheap, frequent
    allocations put pressure on the \dotnet{} garbage collector, leading to unnecessary stalls.
    Therefore, the amount of heap allocation on hot paths of the code executions should be
    minimized.

    \litem{Prefer return codes over exceptions} Throwing an exception is an expensive operation, and
    their frequent use would have negative impact on the performance.

\end{itemize}

\subsection{Testability}

The second design aspect we would focus on is testability of the implementation. Ideally, the design
would minimize the need for live debugging of the implementation. This is especially important
because stopping the implementation on a breakpoint will inevitably disrupt the connection, possibly
leading to termination because of a timeout.

The design intention is to allow writing automated tests that are able to inspect the packets sent
by the endpoint, and verify that they are consistent with the behavior defined by the QUIC
specification.

\subsection{Robustness?}

\todo{probably can be removed, can be mentioned when parsing incoming packets}

\subsection{Debugging?}

\todo{consider qlog and quic-log formats}

\section{Target \dotnet{} API}

This section describes API that will be used to expose the QUIC implementation to other developers.
As mentioned in the introduction chapter, the current design is a work-in-progress and is subject to
change in the future. All of the mentioned classes are located in the \namespace{System.Net.Quic}
namespace.

\subsection{QuicListener Class}

The \class{QuicListener} class is the equivalent of the \class{TcpListener}. Servers use this
class to accept incoming QUIC connections.

\begin{description}

    \ditemctor{QuicListener}{QuicListenerOptions} Constructor.

    \ditemproperty{IPEndPoint}{ListenEndPoint}{\propget} The IP endpoint being listened to for new connection. Read-only.

    \ditemmethod{ValueTask<QuicConnection>}{AcceptConnectionAsync}{CancellationToken}
    Accepts a new incoming QUIC Connection.

    \ditemmethod{void}{Start}{} Starts listening.

    \ditemmethod{void}{Close}{} Stops listening and closes the listener. Does not close already accepted connections.

\end{description}

\subsection{QuicListenerOptions Class}

The \class{QuicListenerOptions} class holds all configuration used to construct new \class{QuicListener}s.

\begin{description}

    \ditemproperty{SslServerAuthenticationOptions}{ServerAuthenticationOptions}{\propgetset}
        SSL related options like certificate selection/validation callbacks, and supported protocols for ALPN\@.

    \ditemproperty{string}{CertificateFilePath}{\propgetset} Path to the X509 certificate used by the server.

    \ditemproperty{string}{CertificateKeyPath}{\propgetset} Path to the private key for the used X509 certificate.

    \ditemproperty{string}{CertificateKeyPath}{\propgetset} Path to the private key for the used X509 certificate.

    \ditemproperty{IPEndPoint}{ListenEndPoint}{\propgetset} The IP endpoint to listen on.

    \ditemproperty{int}{ListenBacklog}{\propgetset} Number of connection to be held waiting for acceptance by the application. Upon reaching this limit, further connections will be refused.

    \ditemproperty{long}{MaxBidirectionalStreams}{\propgetset} Limit on the number of bidirectional streams the client can open in an accepted connection.

    \ditemproperty{long}{MaxUnidirectionalStreams}{\propgetset} Limit on the number of unidirectional streams the client can open in an accepted connection.

    \ditemproperty{TimeSpan}{IdleTimeout}{\propgetset} The period of inactivity after which the connection will be closed via idle timeout.

\end{description}

\subsection{QuicConnection Class}

The \QuicConnection{} class provides operation on the QUIC connection. Clients open new
connections by creating a new instance of this class and calling the \method{ConnectAsync} method.
Servers receive new connections using the \class{QuicListener} class.

\begin{description}

    \ditemctor{QuicConnection}{QuicClientConnectionOptions} Constructor. The newly created instance is not connected until the call to \method{ConnectAsync} method.

    \ditemproperty{bool}{Connected}{\propget} Indicates whether the \QuicConnection{} is connected (the handshake has completed).

    \ditemproperty{IPEndPoint}{LocalEndPoint}{\propget} Local IP endpoint of the connection.

    \ditemproperty{IPEndPoint}{RemoteEndPoint}{\propget} Remote IP endpoint of the connection.

    \ditemmethod{ValueTask}{ConnectAsync}{CancellationToken} Connects to the remote endpoint.

    \ditemmethod{QuicStream}{OpenUnidirectionalStream}{} Opens a new unidirectional stream. Throws a \class{QuicException} if the stream cannot be opened.

    \ditemmethod{QuicStream}{OpenBidirectionalStream}{} Opens a new bidirectional stream. Throws a \class{QuicException} if the stream cannot be opened.

    \ditemmethod{ValueTask<QuicStream>}{AcceptStreamAsync}{Cancellationtoken} Accepts an incoming stream.

    \ditemmethod{ValueTask}{CloseAsync}{long, CancellationToken} Closes the connection with the specified given error code and terminates all active streams.

    \ditemmethod{long}{GetRemoteAvailableUnidirectionalStreamCount}{} Gets the maximum number of unidirectional streams that this endpoint can open.

    \ditemmethod{long}{GetRemoteAvailableBidirectionalStreamCount}{} Gets the maximum number of bidirectional streams that this endpoint can open.

\end{description}

\subsection{QuicClientConnectionOptions}

The \class{QuicClientConnectionOptions} is used by clients to configure new QUIC conections.

\begin{description}

    \ditemproperty{SslClientAuthenticationOptions}{ClientAuthenticationOptions}{\propgetset} Client authentication options to use when establishing the connection.

    \ditemproperty{IPEndPoint}{LocalEndPoint}{\propgetset} The local IP endpoint that will be bound to.

    \ditemproperty{IPEndPoint}{RemoteEndPoint}{\propgetset} The IP endpoint to connect to.

    \ditemproperty{long}{MaxBidirectionalStreams}{\propgetset} Limit on the number of bidirectional streams the server can open.

    \ditemproperty{long}{MaxUnidirectionalStreams}{\propgetset} Limit on the number of unidirectional streams the server can open.

    \ditemproperty{TimeSpan}{IdleTimeout}{\propgetset} The period of inactivity after which the connection will be closed via idle timeout.

\end{description}

\subsection{QuicStream Class}

The \class{QuicStream} class represents a single stream in a QUIC connection. This class inherits
from the abstract \class{Stream} class. The list below mentions only members specific for the \class{QuicStream} class, members from the \class{Stream} base class are omitted.

The class contains methods for both inbound and outbound streams. Invoking read methods on
write-only stream will cause an exception to be thrown and vice versa.

\begin{description}

    \ditemproperty{long}{StreamId}{\propget} The Stream ID\@.

    \ditemmethod{void}{AbortRead}{long} Aborts the receiving part of the stream with the provided error code.

    \ditemmethod{void}{AbortWrite}{long} Aborts the sending part of the stream with the provided error code.

    \ditemmethodWithComment{ValueTask}{WriteAsync}{*, CancellationToken}{multiple overloads} Multiple overloads of this method offer writing from various types of buffers: \class{ReadOnlyMemory<byte>}, \class{ReadOnlySequence<byte>}, and \class{ReadOnlyMemory\allowbreak<ReadOnlyMemory<byte>>}. The returned task completes when the provided data have been buffered internally and the buffers can be reused for other purposes.

    \ditemmethodWithComment{ValueTask}{WriteAsync}{*, bool, CancellationToken}{multiple overloads} Like the methods above, but also allow specifying that the provided data are the last on the stream and that the stream should be gracefully closed.

    \ditemmethod{ValueTask}{ShutdownWriteCompleted}{CancellationToken} The returned task completes when the stream shutdown completes. Meaning that acknowledgement from the peer is received.

    \ditemmethod{ValueTask}{Shutdown}{} Closes the stream with error code 0. And blocks until shutdown completes.

\end{description}

\subsection{Exceptions}

The QUIC API can throw following exceptions:

\begin{description}

    \ditem{\ditemsrcsize\class{QuicException}} Base class for all thrown exceptions, used when a more specific exception is not available

    \ditem{\ditemsrcsize\class{QuicConnectionAbortedException}} Thrown when the connection is forcibly closed either by the transport or by the remote endpoint.

    \ditem{\ditemsrcsize\class{QuicStreamAbortedException}} Thrown when the stream was aborted by the remote endpoint.

    \ditem{\ditemsrcsize\class{QuicOperationAbortedException}} Thrown when the pending operation was aborted by the local endpoint.

\end{description}

\section{TLS Implementation}

TLS handshake forms an integral part of the QUIC connection establishment. Because correct TLS
implementation is crucial for ensuring the security of the resulting implementation, this thesis
should avoid implementing TLS by itself. Instead, it should reuse some existing and well-tested
implementation.

The novel way in which QUIC integrates with TLS requires specific functionality on the API of the
TLS implementation. Below is a nonexhaustive list of operations the TLS library's API must provide:

\begin{itemize}

  \item Current state of te handshake

  \item Temporary keys used to protect the handshake process

  \item Raw unencrypted TLS messages to be sent to the other endpoint

  \item Negotiated cipher

  \item Specifying protocols used for ALPN

  \item Specifying custom TLS extension to exchange QUIC transport parameters

\end{itemize}

\subsection{TLS 1.3 Support in \dotnet{}}

The \dotnet{} runtime libraries use different native libraries to provide TLS functionality on
different operating systems. On Windows, \libname{Secure Channel}~\cite{Schannel} (\libschannel{}
for short), which is part of the Windows operating system. On Linux and macOS systems, the
\libopenssl{} library~\cite{OpenSSLWeb} is used.

\begin{description}

    \ditem{\libname{Secure Channel}} The \libschannel{} versions present in the latest Windows 10
    builds support only TLS 1.2.  However, future near updates will implement also TLS 1.3. The
    \libschannel{} version with TLS 1.3 support can be obtained by installing an insider preview
    build of Windows 10.

    The \libmsquic{} library uses \libschannel{} library when compiled for Windows. Therefore, we
    assume that \libschannel{} exposes the necessary API for our managed QUIC implementation.

    \ditem{\libopenssl{}}
    None of the released versions of \libopenssl{} library expose necessary API for integration
    with QUIC, and there are no plans to include such API in the next \libopenssl{} 3.0.0
    release~\cite{OpensslBlogNoQuic}.

    However, developers at Akamai maintain a fork of \libopenssl{} which adds the QUIC-enabling
    API~\cite{AkamaiOpensslGithub}. This modified version of \libopenssl{} is used by \libmsquic{}
    (on Linux) and other QUIC libraries \todo{mention them by name + link?: quiche}. It is possible
    that the changes made by Akamai will be merged into \libopenssl{} for the 3.1.0 or later
    releases.

\end{description}

In conclusion, the APIs required for our QUIC implementation are currently only accessible in only
the preview versions of Windows 10. Relying solely on \libschannel{} for TLS 1.3 support in our
prototype implementation would severely impact cross-platform availability.

The \libopenssl{} library and supports all platforms supported by \dotnet{}, and could therefore be
used to implement TLS integration into QUIC in a platform-compatible manner. This solution, however,
has some drawbacks:


\begin{itemize}

  \item Modified \libopenssl{} binary must be distributed with \dotnet{} runtime.

  \item Only limited integration with X.509 certificates is possible because the
    \class{X509Certificate} class implementation will be using different binary ---
    \libname{CryptoAPI} on Windows, unmodified \libopenssl{} on Linux and macOS.

\end{itemize}

These drawbacks are acceptable for the prototype implementation, and will be eliminated once the
modified \libopenssl{} is replaced with \libschannel{} integration for Windows, and mainstream
version of \libopenssl{} once the support for QUIC is released.

This thesis will therefore integrate with the forked \libopenssl{} library from Akamai. Because the
library is written in C, it has to be integrated to the build process to be build together with the
native code of the \dotnet{} runtime.

\section{Threading model}

Implementation of the QUIC connection requires some background processing for handling timeouts and
reacting to incoming packets. Together with user threads, there will be more than one
thread\footnote{To reduce verbosity, this text will be using term thread to mean both code executing on a
  dedicated \class{Thread} or code running on the thread-pool using the \class{Task} type and
  \dotnet{} async/await model.} accessing the internal state of the connection.

\subsection{Public API}

The target API is designed to use the \class{ValueTask} type designed for efficient asynchronous
method implementation. Using this type, user code will start an asynchronous operation, that can be
completed by a background thread servicing the connection. This way the user code cannot block the
execution of the connection's background thread which could otherwise cause timeouts to be missed.

The implementation should make possible to use the \QuicConnection{} from multiple threads when
it makes sense. For example, it can be useful to be able to process individual QUIC streams in
parallel. Therefore, when designing the implementation we will assume following threading model for
the API:

\begin{itemize}

  \item Individual streams can be accessed concurrently. However, a single stream can be
    accessed only by one thread at a time.

  \item Accepting/opening new streams on a connection can be done concurrently from multiple threads.

  \item All other operations on \QuicConnection{} must be synchronized. This includes, e.g.,
    starting and aborting the connection.

\end{itemize}

\subsection{Internal Connection State}

To reduce the need for internal synchronization as much as possible in the \QuicConnection{}
implementation, our implementation will allow only a single thread to access the internal connection
state. The cost of synchronization of multi-threaded access would likely outweigh the benefits of
parallelism.

\section{High-Level Architecture}

Server implementation will need to be able to use a single IP address and port for conducting
multiple QUIC connections. Also, during connection migration on clients. The connection will need to
accept datagrams from multiple sockets at the same time. Although the prototype implementation will
omit the connection migration feature, the architecture should allow it's implementation in the
future.

Instead of interacting with the underlying \class{Socket} instance from the \QuicConnection{} class
directly, our implementation will introduce a new \QuicSocketContext{} class to perform the socket
I/O and background processing. \autoref{fig:03-architecture} shows how the \QuicSocketContext{}
class fits into the architecture.

\begin{myFigure}{fig:03-architecture}{High-level background processing architecture.}

  \input{img/03-architecture.pdf_tex}

\end{myFigure}

If necessary, the implementation of \QuicSocketContext{} class can be different for server and
client endpoints. For example, server implementation may need to utilize multiple background
processing threads to be able to handle large number of connections without degrading performance.

\todo{mention future support for connection migration?}

Separation of I/O from \QuicConnection{} outlined in previous subsection also makes the
implementation more testable. The interface between the \QuicSocketContext{} and \QuicConnection{}
will consists of passing buffers with received UDP datagrams and datagrams to be sent.

Therefore, automated tests can inspect the contents of the sent datagrams and inject specially
crafted datagrams to provoke behavior to be tested. The testing code can also manually step time to
make the tests deterministic.

\section{QuicSocketContext Implementation}

The connection background processing will need to process the following events:

\begin{itemize}

  \item An incoming UDP datagram has arrived on the socket.

  \item User has performed some action that potentially requires sending UDP datagrams to the other
    endpoint. This includes e.g. writing data to a stream or aborting a stream.

  \item A timeout has expired, this includes e.g. timeout for loss detection.

\end{itemize}

\subsection{Incoming packet handling}

\subsection{User request handling}
\subsection{Timeout events}


\section{Epoch handling}
\subsection{Separation of epochs in protocol}

\section{Packet Protection}

As described in \autoref{sec:packet-protection}, the packet encryption consists of two phases ---
payload protection and header protection. The combined process requires following inputs:

\begin{itemize}

  \item Keys derived from the protection secrets (as explained in
  \autoref{sec:02-encryption-key-derivation})

  \item Negotiated cipher

  \item Packet number (for encryption), or expected packet number (for decryption)

  \item The QUIC packet to encrypt or decrypt

\end{itemize}

The cipher is negotiated once and cannot be changed during the lifetime of the connection. Keys for
the protection can be changed only for the 1-RTT packets using the process of \textit{key update}
(see \autoref{sec:02-key-update}), which can be expected to be relatively infrequent. The rest of
the inputs change with every packet. Therefore, our implementation encapsulates the packet
protection implementation in a \class{CryptoSeal} class, which does not depend on the rest of the
QUIC implementation.

The process of receiving packets requires intermediate validation of the header fields. The
individual steps --- header protection and payload protection --- must be therefore exposed separately.
Also, the protection should happen in-place to avoid unnecessary allocations and copying of the
packets.

An important consideration needs to be made for performing the actual encryption/decryption once all
inputs to the AEAD have been gathered. \dotnet{} does not contain an implementation of the CHACHA
family of ciphers. Because the implementation can work without it by instructing TLS library to not
allow its negotiation, the prototype implementation of QUIC will not support this kind of cipher.
The other ciphers are based on the AES family of ciphers, which are supported by \dotnet{}, but
individual classes implementing these ciphers do not share a common interface. Our implementation
therefore wraps the concrete AES implementations in classes derived from an abstract
\class{CryptoSealAlgorithm} class defining a common interface required by \CryptoSeal{}.
\autoref{fig:03-crypto-seal} illustrates how the \CryptoSeal{} and \class{CryptoSealAlgorithm}
classes are connected.

\begin{myFigure}{fig:03-crypto-seal}{Relationship between CryptoSeal and CryptoSealAlgorithm classes}

  \resizebox{\linewidth}{!}{\input{img/03-crypto-seal.pdf_tex}}

\end{myFigure}

Key update can be implemented by replacing the existing instance of the
\CryptoSeal{} class with the new one with the updated protection secret.

\section{Packet Serialization/Deserialization}

Special care needs to be taken when implementing serialization of the QUIC packets to the wire
format because inefficient implementation can have very negative impact on the overall performance.
Because significant amount of time is spent parsing and processing individual QUIC frames. The
packet and frame representation should be carefully designed to avoid allocations on the hot path.

The incoming packets can contain arbitrary encoding errors which should be handled without the use
of exceptions for above-mentioned performance reasons. Therefore, all possible errors encountered
during packet deserialization must be handled gracefully. This includes values being outside of
range of allowed values and incomplete or damaged packets.

\subsection{QUIC Packet and Frame Representation}

Some packets contain a large number of fields and, therefore, passing them around as individual
variables would make the implementation unnecessarily verbose. Logically, the QUIC frames form
coherent messages that should be represented by individual \dotnet{} types.

Representing QUIC frames as instances of individual classes would introduce a lot of allocation for
every received QUIC packet. This thesis therefore models QUIC frames headers of QUIC packets as value types.

Payload of some frames may consist of large blocks of memory. Examples include \STREAM{} and
\CRYPTO{} frames, which can fill the entire payload of the QUIC packet. Duplicating this block of
memory would be another unnecessary memory allocation. Recent versions of \dotnet{} \todo{which
  one?} introduced the \class{Span<T>} type which can be used to efficiently reference arbitrary
memory block, including memory allocated on stack using the \keyword{stackalloc} keyword.

However, the \class{Span<T>} type is a \keyword{ref struct} --- a special kind of value type which can
be stored only on program stack, or inside other \keyword{ref struct}s. One of the consequences of
using \keyword{ref struct}s to represent QUIC frames is that it is impossible to create a collection
containing all frames from the QUIC packet. All frames must be processed right after they are
parsed. This limitation would greatly complicate writing tests for the \class{QuicConnection}
behavior. Fortunately, this limitation can be overcome by also creating reference type versions of
the frame types to be used in the testing framework. Even though this introduces duplication to the
codebase, we believe that having allocation-free packet serialization justifies this decision.

\subsection{QuicReader and QuicWriter}

Both serialization and deserialization requires maintaining the current position in the buffer
containing the memory to deserialized. To simplify this, our implementation introduces \QuicReader{}
and \QuicWriter{} classes as a primary means to reading and writing QUIC primitives to memory.
Although \QuicReader{} and \QuicWriter{} are reference types allocated on the heap, their instances
are expected to be cached by the class that uses them.

\todo{I feel big-endianity should be mentioned, but I can't find a good place for it} Like many
other networking protocols, QUIC uses \textit{network order} of bytes, also called
\textit{big-endian} order.

\subsection{QUIC Primitives Encoding}

There are two primitives used in QUIC packet encoding that require nontrivial encoding. The first
one being variable-length integer encoding, the other one being packet number encoding. Both of
these encodings are described in \autoref{sec:wire-encoding}.

\todo{this feels like there should be more in this subsection}

\section{Stream Implementation}

QUIC is a transport protocol and therefore its entire purpose is transferring streams of data. Since
it is likely to be the hot path of the implementation, the internal handling of streams must be
efficient and avoid unnecessary copying of blocks of stream data.

QUIC recognizes four types of streams. These streams can have sending part, receiving part, or both.
The fact which endpoint initiated the stream controls only which flow control limits apply to that
stream. Otherwise all streams are handled equally.

\subsection{Receiving Part of the Stream}

The implementation of the receiving part of the stream must be able to buffer the received data in
case the QUIC packets send by the peer were lost or reordered. It also needs to track the amount of
buffered memory and how much data wad delivered to the application in order to correctly update flow
control limits for the peer.

\subsubsection{Stream Data Buffering}

Ideally, the stream implementation would be structured in a way that the stream data were copied
straight from the decrypted packet to the memory provided by the application. This would be possible
if the API used an event-based model with callbacks for incoming data. The API, as currently
designed, utilizes method-based model. If the application does not call the \method{ReadAsync}
method, there is no buffer to deliver to.

In order to avoid additional copies, the buffer holding the stream data cannot be reused to receive
another QUIC packet, because the part of the buffer with the \STREAM{} frame must be kept unmodified
until delivered to the application. Instead, different buffer must be obtained for receiving the
next packet. For such a solution to be memory efficient, it would require a complex memory pooling
scheme to avoid needlessly, essentially implementing a custom memory allocator over a block of
memory. The performance improvement of such a solution may be greatly outweighed by the development
and maintenance costs. Therefore, until the cost of such a solution is justified by performance
measurements, our implementation will use a two-copy approach: the first copy from the packet to
internal stream buffers, the second copy from said buffers to the destination memory provided by the
application.

\subsubsection{Packet Reordering and Data Deduplication}

Unreliability of the UDP protocol can cause QUIC packets to be reordered or lost. Because of that,
parts of the stream may be received multiple times, and the contents of \STREAM{} frames can
arbitrarily overlap. It is therefore necessary to keep track which parts of the stream have been
received and buffer only the newly received segments of the stream.



The \STREAM{} frames can

\subsubsection{Reading data by user}
\subsubsection{Flow control consideration}

\subsection{Outbound part}

\subsubsection{Buffering}
\subsubsection{Acknowledgement, retransmission}
\subsubsection{Flow control consideration}

\subsection{Abort/Dispose model for streams}
\subsection{Managing streams within connection}
\subsection{Queue of streams to be updated}


\section{Flow control}

\subsection{Connection level}
\subsection{Stream level}
\subsection{MaxStreams and API}


\section{Recovery/Robustness}

\subsection{Detecting lost packets}
\subsection{Detecting duplicate packets}
\subsection{Tail loss probe}
\subsection{Congestion window}
\subsection{Interface for Congestion control algorithm}

\section{Integration:}

\todo{should be after TLS because of OpenSSL dependency}

\subsection{Build as part of dotnet runtime}
\subsection{Standalone build for easier evaluation}

\todo{Maybe remove altogether and move this to documentation}
