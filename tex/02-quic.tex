\chapter{QUIC Protocol}\label{chap:02-quic}

This chapter is intended as a summary of the QUIC protocol specification and aims to provide
sufficient background for the design of our implementation. This text is based on version 29 of the
draft specification documents from June 2020, more specifically on the documents describing the core
transport protocol~\cite{draft-ietf-quic-transport}, TLS integration~\cite{draft-ietf-quic-tls}, and
congestion control mechanism~\cite{draft-ietf-quic-recovery}. Readers familiar with these documents
may skip this chapter.

We will start this chapter by first providing a high-level overview of QUIC and then providing a
more detailed description of the protocol's individual parts.

\section{Introduction}

QUIC protocol provides reliable and secure transport of multiple streams of data over a single
connection. QUIC provides following services:

\begin{itemize}

  \item Stream multiplexing

  \item Stream and connection-level flow control

  \item Low-latency connection establishment

  \item Connection migration and resilience to NAT rebinding

\end{itemize}

QUIC is implemented on top of UDP, which provides only unreliable transfer of datagrams. Therefore,
in addition to stream multiplexing, QUIC also implements loss recovery, congestion control,
transport security, and other features known from TCP or TLS protocols.

\subsection{Basic Concepts}

Throughout this chapter, and later when analysing the QUIC protocol specification, this text will
use several terms in a very specific meaning. This meaning is the same as defined in the
main specification document~\cite[Section~1.2]{draft-ietf-quic-transport}.

\todo{again, following list is almost verbatim from RFC}

\begin{description}

  \ditem{QUIC packet}  A complete processable unit of QUIC that can be
    encapsulated in a UDP datagram.  Multiple QUIC packets can be
    encapsulated in a single UDP datagram.

  \ditem{Out-of-order packet}  A packet that does not arrive directly after the packet that was
    sent before it.  A packet can arrive out of order if it is delayed, if earlier packets are
    lost or delayed, or if the sender intentionally skips a packet number.

   \ditem{Endpoint}  An entity that can participate in a QUIC connection by
      generating, receiving, and processing QUIC packets.  There are
      only two types of endpoint in QUIC: client and server.

   \ditem{Client}  The endpoint initiating a QUIC connection.

   \ditem{Server}  The endpoint accepting incoming QUIC connections.

  \ditem{Address}  When used without qualification, the tuple of IP version,
    IP address, UDP protocol, and UDP port number that represents one
    end of a network path.

  \ditem{Connection ID}  An opaque identifier that is used to identify a QUIC
    connection at an endpoint.  Each endpoint sets a value for its
    peer to include in packets sent towards the endpoint.

  \ditem{Stream}  A unidirectional or bidirectional channel of ordered bytes
    within a QUIC connection.  A QUIC connection can carry multiple
    simultaneous streams.

  \ditem{Application}  An entity that uses QUIC to send and receive data.

\end{description}

\subsection{Notational Conventions}

Numeric constants in hexadecimal always use network byte order (big-endian) and are prefixed by 0x.
In case of constants of non-conventional integer sizes, such as 2-bit integers used in packet
fields, the notation will omit unnecessary leading zeros. For example, \binary{FE} represents
decimal number 254 and \binary{2} represents decimal number 2.

This chapter contains graphical diagrams of several elements such as QUIC packets. In those
schematics, individual fields include length information as follows:

\begin{itemize}

  \litem{X (A)} Indicates that X is A bits long.

  \litem{X (i)} Indicates that X is encoded using the QUIC's variable-length encoding. This encoding is described in \autoref{sec:02-variable-length-encoding}.

  \litem{X (A..B)} Indicates that X can be any length from A to B, either of these limits can be omitted to indicate minimum size of zero, or no upper size limit, respectively.

  \litem{X (A) = C} Indicates that X has a fixed value C.

  \litem{X (A) ...} Indicates that X has is repeated zero or more times and each instance is A bits long.

\end{itemize}

\subsection{Wire Encoding}\label{sec:02-wire-encoding}

The process of encoding QUIC packets to be sent via the network is optimized for size. All values
sent over the network are encoded in big endian order. There are two nontrivial encodings used:
variable-length integer encoding and packet number encoding.

\subsubsection{Variable-Length Integer Encoding}\label{sec:02-variable-length-encoding}

Almost all numeric values stored in QUIC packets are encoded using a \textit{variable-length integer
  encoding}. This encoding uses the first byte's two most significant bits to encode whether the
value is encoded as 1, 2, 4, or 8-byte integer. This encoding supports only positive numbers. The
ranges available for individual encoding lengths are listed in \autoref{tab:02-quic-varint-length}.

\begin{myTable} {tab:02-quic-varint-length} {Variable-length integer encoding lengths}
  {ccr}
  {Most significant bits & Encoding length (B) & Maximum value}
  \binary{0}             & 1                   & \num{63}         \\
  \binary{1}             & 2                   & \num{16383}      \\
  \binary{2}             & 4                   & \num{1073741824} \\
  \binary{3}             & 8                   & $2^{62}-1$       \\
\end{myTable}

In order to optimize the size of QUIC packets, the implementations are encouraged to always choose
the shortest encoding necessary to represent the given number.

\subsubsection{Packet Number Encoding}\label{sec:02-packet-number-encoding}

\todo{check this for legibility}

Packets in QUIC are sequentially numbered and, therefore, packet numbers received by an endpoint
form a mostly ascending sequence with occasional reordering or gaps due to network unreliability.
This causes the packet number of a newly received packet to be close to that of the previously
received packet. QUIC leverages this fact by sending only the lower bytes of the packet number. The
number of bytes sent is variable between one to four bytes and is always chosen so that the receiver
can reconstruct the original packet number using the previously received packet numbers and the
bytes from the arriving packet.

When determining how many bytes of the packet number need to be included in the packet, the sender
uses the value of the highest acknowledged packet number. The encoding length must use enough bytes
to be able to represent at least twice the difference between the current packet number and the
highest acknowledged number.

As an example, consider following situation: as sender prepares to send packet \binary{4417}, its
highest acknowledged packet number is \binary{43a0}. The difference between the two numbers is
\binary{77} which is still small enough to require only the least significant byte (\binary{17}) of
the packet number to be sent in the packet. Suppose that by the time the packet arrives at the
receiver, its highest received packet number is \binary{43f5}. Based on the encoded packet number
length, the deconstructed packet number must be from the range \binary{4375}--\binary{4475}. The only
number from this range which matches the least significant byte sent in the packet is \binary{4417}
which is the correct packet number.

\section{QUIC Packets}

In QUIC connection, endpoints exchange \textit{QUIC packets} enclosed in UDP datagrams. A single UDP
datagram can contain multiple packets, although in most cases they contain only one. Packing
multiple QUIC packets into a single UDP datagram is called \textit{coalescing}. A single QUIC packet
cannot span multiple UDP datagrams. QUIC uses a total of six different packet types:

\todo{The order of the packet here now matches the subsubsections later, but I think different order here might be better}

\begin{enumerate}

  \litem{Version Negotiation} sent by the server when the client tries to establish a connection
  with QUIC version that is not supported by the server;

  \litem{Retry} optionally used by servers for Client Address Validation \todo{forward reference
  address validation} when establishing new connections;

  \litem{Initial} used to initiate a new connection and exchange the initial information;

  \litem{Handshake} used during the connection handshake;

  \litem{0-RTT} when TLS 1.3 0-RTT mode of operation is enabled, 0-RTT packets carry \textit{early
  data} --- application data that is sent before the TLS handshake is complete in order to reduce
  latency; and

  \litem{1-RTT} main packet type used throughout the lifetime of QUIC connection. 1-RTT and 0-RTT
  packets are the only packet types which carry application data.

\end{enumerate}

Version Negotiation and Retry packets are sent as one-time responses in special scenarios and are
not individually numbered. QUIC is designed in a way that lets the server send these packets without
maintaining any state for the connection. These packets are not used in an established connection.

Packets of the other types --- Initial, Handshake, 0-RTT and 1-RTT --- are individually numbered. The
packet numbers do not form a single sequence, as is the case with TCP packets. Instead, QUIC
organizes these packets into three separate \textit{packet number spaces}, and uses a separate
sequence of numbers for each packet number space. These packet number spaces are:

\begin{enumerate}

  \litem{Initial} Used for initiating new connections and exchanging initial cryptographic
  information. Contains only Initial packets.

  \litem{Handshake} Used during the connection handshake process. Contains only Handshake packets.

  \litem{Application} Used throughout the lifetime of the connection to transfer application data.
  This packet space contains both 0-RTT and 1-RTT packets.

\end{enumerate}

In addition to being numbered separately, packets from each packet number space are processed
completely independently of the other packet number spaces. For example, Initial packets can be
acknowledged only by another Initial packet. In their payload, the Initial, Handshake, 0-RTT and
1-RTT packets carry \textit{QUIC Frames} which are low level protocol messages carrying e.g.
acknowledgements and parts of streams sent by the application.

Each packet type has a header and a payload. QUIC tries to optimize the packet encoding in order to
maximize the amount of application data that can be sent in a single UDP datagram. Therefore, two
types of packet headers exist. 1-RTT packets use a \textit{short header} and all other packet types
use the \textit{long header}. The short header contains only a subset of fields present in the long
header and omits data which are relevant only during connection establishment, like protocol version
identifier.

The type of the header is specified by the most significant bit of the first byte in the packet ---
the \textit{Header Form} bit. The second most significant bit --- the \textit{Fixed Bit} --- is always
set to 1 in valid QUIC packets. Following sections describe the structure of the rest of the packet
for individual packet types.

\newcommand{\longFieldHeight}{1}

\subsection{Long Packet Header}

Long headers contain information that is necessary for the connection establishment. It includes
both the Source and Destination Connection IDs. It also contains \textit{Version} and \textit{Packet
  Type} fields. A few leftover bits of the header are reserved for type-specific information. The
structure of the long header is illustrated in \autoref{fig:02-long-header}.

\begin{myFigure}{fig:02-long-header}{Long packet header structure}

  \begin{bytefield}[bitwidth=2.5em]{8}
    \bitheader{0-7} \\
    \bitbox{1}{H=1} & \bitbox{1}{F=1} & \bitbox{2}{T (2)} & \bitbox{4}{Type Specific Bits (4)} \\
    \wordbox[tlrb]{\longFieldHeight}{Version (32)} \\
    \wordbox[tlrb]{1}{Destination Connection ID Length (8)} \\
    \wordbox[tlrb]{\longFieldHeight}{Destination Connection ID (..) } \\
    \wordbox[tlrb]{1}{Source Connection ID Length (8)} \\
    \wordbox[tlrb]{\longFieldHeight}{Source Connection ID (..) } \\
  \end{bytefield}

  H = Header Form, F = Fixed Bit, T = Packet Type

\end{myFigure}

The semantics of the individual fields of the long header is as follows:

\begin{description}

    \ditem{Header Form Bit} used to distinguish between packets with so called \textit{long header}
    and \textit{short header} format. In case of the long header packets. the form bit is set to \binary{1}.

    \ditem{Fixed Bit} A bit that is always set to \binary{1} in valid QUIC packets.

    \ditem{Packet Type} Discriminator of the packet type. the possible values are listed in \autoref{tab:02-packet-type}.

\begin{myTable}{tab:02-packet-type}{Values of the Packet Type field in long packet header}
  {cc}
  {Packet Type & Value}
  Initial      & \binary{0} \\
  0-RTT        & \binary{1} \\
  Handshake    & \binary{2} \\
  Retry        & \binary{3} \\
\end{myTable}

    \ditem{Version} Indicates which version of QUIC is in use. Location of this field will be
    the same across all QUIC versions However, the structure of the rest of the packet may be different
    in future versions of QUIC.

    \ditem{Destination Connection ID Length} Length of the Destination Connection ID field.

    \ditem{Destination Connection ID}  The Connection ID issued by the recipient of the packet.

    \ditem{Source Connection ID Length}  Length of the Source Connection ID field.

    \ditem{Source Connection ID} The Connection ID issued by the sender of the packet.

    \ditem{Reserved Bits} Bits reserved for use in the future QUIC versions. In the initial QUIC
    version, these bits must be set to 0.

\end{description}

\subsection{Version Negotiation Packet}\label{sec:02-version-negotiation-packet}

The Version Negotiation packet is sent by the server when it receives a long header packet
requesting a version of QUIC unsupported by the server. As an exception to other long header
packets, Version Negotiation packet is not discriminated by a specific value in the Packet Type
field in the header, but by a special value \binary{00000000} in the Version field.

After the header, the packet contains a list of supported versions, each one listed as 32-bit
integer in big-endian. Also, since future QUIC versions may allow larger Connection IDs than 20
bytes, a valid Version Negotiation packet can contain up to 255-byte Connection IDs. The structure
of the Version Negotiation packet is illustrated in \autoref{fig:02-version-negotiation-packet}.

\begin{myFigure}{fig:02-version-negotiation-packet}{Version Negotiation packet structure}

  \begin{bytefield}[bitwidth=2.5em]{8}
    \bitheader{0-7} \\
    \begin{rightwordgroup}{long \\ header}
      \bitbox{1}{H=1} & \colorbitbox{bytefieldunused}{7}{Unused} \\
      \wordbox[tlrb]{\longFieldHeight}{Version (32) = \binary{00000000}} \\
      \wordbox[tlrb]{1}{Destination Connection ID Length (8)} \\
      \wordbox[tlrb]{\longFieldHeight}{Destination Connection ID (0..2040) } \\
      \wordbox[tlrb]{1}{Source Connection ID Length (8)} \\
      \wordbox[tlrb]{\longFieldHeight}{Source Connection ID (0..2040) }
    \end{rightwordgroup} \\
    \wordbox[tlrb]{\longFieldHeight}{Supported Version 1 (32)} \\
    \wordbox[tlrb]{\longFieldHeight}{Supported Version 2 (32)} \\
    \wordbox[tlrb]{1}{...} \\
  \end{bytefield}

  H = Header Form

\end{myFigure}

The identifier of the initial QUIC version is \binary{00000001}. There are also special identifiers
for draft versions of the protocol valid only until the QUIC specification is finalized.

\subsection{Retry Packet}\label{sec:02-retry-packet}

Retry packets are distinguished by value \binary{3} in the \textit{Packet Type} field of the long
header. Retry packets are sent by a server as part of the optional \textit{Address Validation}
mechanism used to protect against traffic amplification attack. \todo{forward ref to address
  validation?} The structure of the packet is illustrated in \autoref{fig:02-retry-packet}.

\begin{myFigure}{fig:02-retry-packet}{Retry packet structure}

  \begin{bytefield}[bitwidth=2.5em]{8}
    \bitheader{0-7} \\
    \begin{rightwordgroup}{long \\ header}
      \bitbox{1}{H=1} & \bitbox{1}{F=1} & \bitbox{2}{T=\binary{3}} & \colorbitbox{bytefieldunused}{4}{Unused} \\
      \wordbox[tlrb]{\longFieldHeight}{Version (32)} \\
      \wordbox[tlrb]{1}{Destination Connection ID Length (8)} \\
      \wordbox[tlrb]{\longFieldHeight}{Destination Connection ID (0..160) } \\
      \wordbox[tlrb]{1}{Source Connection ID Length (8)} \\
      \wordbox[tlrb]{\longFieldHeight}{Source Connection ID (0..160) }
    \end{rightwordgroup} \\
    \wordbox[tlrb]{\longFieldHeight}{Retry Token (..)} \\
    \wordbox[tlrb]{\longFieldHeight}{Retry Integrity Tag (128)} \\
  \end{bytefield}

  H = Header Form, F = Fixed Bit, T = Packet Type

\end{myFigure}

The semantics of the fields specific to the Retry packet are:

\begin{description}

    \ditem{Retry Token} Contains an opaque token generated by the server. This token must be
    echoed back in an Initial packet during next connection attempt. The contents of the token must be
    difficult to guess by the attacker and verifyable in a stateless manner (i.e. without saving it in
    memory for future comparisons).

    \ditem{Retry Integrity Tag} Tag used to check the integrity of the packet. For the details on
    how the ingegrity tag is calculated, refer to the TLS integration
    specification~\cite[Section~5.8]{draft-ietf-quic-tls}.

\end{description}

\subsection{Initial, Handshake and 0-RTT Packets}

Initial, Handshake and 0-RTT packets are almost identical in structure. All three types use the
\textit{Type-Specific Bits} from the long header to store \textit{Reserved Bits} and the
\textit{Packet Number Length}. After the long packet header, these packets contain the
\textit{Length} field containing the packet length, \textit{Packet Number} field and the actual
payload consisting of QUIC frames. The only exception to this structure is the Initial packet, which
contains two additional fields just after the long header: \textit{Token Length} and \textit{Token},
which are used to carry the Retry Token from the Retry packet in case Address Validation is
requested by the server. The structure of these three packets is illustrated in
\autoref{fig:02-initial-handshake-0rtt-packets}.

\begin{myFigure}{fig:02-initial-handshake-0rtt-packets}{Structure of the Initial, Handshake, and 0-RTT packets}

  \begin{bytefield}[bitwidth=2.5em]{8}
    \bitheader{0-7} \\
    \begin{rightwordgroup}{long \\ header}
      \bitbox{1}{H=1} & \bitbox{1}{F=1} & \bitbox{2}{T (2)} & \bitbox{2}{R=\binary{0}} & \bitbox{2}{L (2)} \\
      \wordbox[tlrb]{\longFieldHeight}{Version (32)} \\
      \wordbox[tlrb]{1}{Destination Connection ID Length (8)} \\
      \wordbox[tlrb]{\longFieldHeight}{Destination Connection ID (0..160) } \\
      \wordbox[tlrb]{1}{Source Connection ID Length (8)} \\
      \wordbox[tlrb]{\longFieldHeight}{Source Connection ID (0..160) }
    \end{rightwordgroup} \\
    \begin{leftwordgroup}{Initial \\ only}
      \colorbitbox{bytefieldunused}{8}{Token Length (i)} \\
      \colorwordbox{bytefieldunused}{tlrb}{\longFieldHeight}{Token (..)}
    \end{leftwordgroup} \\
    \wordbox[tlrb]{1}{Length (i)} \\
    \wordbox[tlrb]{1}{Packet Number (8..32)} \\
    \wordbox[tlrb]{\longFieldHeight}{Packet Payload (..)} \\
    \wordbox[tlrb]{\longFieldHeight}{Integrity Tag (16)} \\
  \end{bytefield}

  H = Header Form, F = Fixed Bit, T = Packet Type,\\
  R = Reserved Bits, L = Packet Number Length

\end{myFigure}

The semantics of the new fields in these packets are:

\begin{description}

    \ditemWithComment{Token Length}{Initial only} Length of the Token field.

    \ditemWithComment{Token}{Initial only} Contains an opaque token if the server provided
    one in the Retry packet as part of Address Validation.

    \ditem{Reserved Bits} Bits reserved for use in the future QUIC versions. In the initial QUIC
    version, these bits must be set to 0.

    \ditem{Packet Number Length} The length of the encoding used for the packet number.

    \ditem{Length} The length of the remainder of the packet. This includes the Packet Number,
    the payload of the packet, and --- for encrypted packets --- the AEAD integrity tag.

    \ditem{Packet Number} The sequence number of this packet in the respective packet number space.
    This field uses a special encoding which is described in \autoref{sec:02-packet-number-encoding}.

    \ditem{Packet Payload} Serialized sequence of QUIC frames.

    \ditem{Integrity Tag} Opaque checksum produced by the AEAD cipher during packet encryption.
    Packet encryption is described in detail in \autoref{sec:02-packet-protection}.

\end{description}

\subsection{1-RTT Packet}

1-RTT packets are the only packet that uses the short header to make more space for application data
in the UDP datagram. Besides the Header Form, Fixed, Reserved Bits and Packet Number Length fields
which have the same meaning as in the long header, short header contains \textit{Spin Bit} and
\textit{Key Phase Bit} fields.

1-RTT packets can be sent only after the connection has been successfully established. This implies
that connection IDs used for the connection by both endpoints are already known, and there is no
need to repeat the Source Connection ID or specify the length of the Destination Connection ID.
1-RTT packets also lack the Length field. It is assumed that 1-RTT packets fill the rest of the UDP
datagram. Therefore, after the short header, only the Packet Number field and the QUIC frame payload
follows. The structure of the 1-RTT frame is illustrated in \autoref{fig:02-1rtt-packet}.

\begin{myFigure}{fig:02-1rtt-packet}{1-RTT packet structure}

  \begin{bytefield}[bitwidth=2.5em]{8}
    \bitheader{0-7} \\
    \begin{rightwordgroup}{short \\ header}
      \bitbox{1}{H=0} & \bitbox{1}{F=1} & \bitbox{1}{S} & \bitbox{2}{R=\binary{0}} & \bitbox{1}{K} & \bitbox{2}{L (2)} \\
      \wordbox[tlrb]{\longFieldHeight}{Destination Connection ID (0..160) }
    \end{rightwordgroup} \\
    \wordbox[tlrb]{1}{Packet Number (8..32)} \\
    \wordbox[tlrb]{\longFieldHeight}{Packet Payload (..)} \\
    \wordbox[tlrb]{\longFieldHeight}{Integrity Tag (16)} \\
  \end{bytefield}

  H = Header Form, F = Fixed Bit, S = Spin Bit, \\
  R = Reserved Bits, K = Key Phase Bit, L = Packet Number Length

\end{myFigure}

The semantics of the fields specific to 1-RTT packets are:

\begin{description}

    \ditem{Spin Bit} A bit used for an optional QUIC feature which allows on-path nodes to measure
    connection latency by observing changes in this bit. \todo{describe the SPIN bit feature?}

    \ditem{Key Phase Bit} A bit used to communicate that the keys used for the packet encryption
    need to be updated. Updating the keys is necessary after using them to encrypt certain number of
    packets to provide stronger protection. The mechanism of Key Update is described in
    \autoref{sec:02-key-update}.

\end{description}

\section{QUIC Frames}\label{sec:02-quic-frames}

QUIC frames are low-level QUIC protocol messages carried in the payload of Initial, Handshake, 0-RTT
and 1-RTT packets. Examples of these frames include, e.g., \ACK{} frames carrying acknowledgments
for received packets, \STREAM{} frames carrying the application data, and \CRYPTO{} frames carrying
data for the TLS handshake.

During the lifetime of the connection, all QUIC packets have to be acknowledged by sending ACK in
another packet in the same packet number space. However, not all packets have to be acknowledged
immediately, e.g., acknowledging packets containing only ACK would cause an endless flood of ACK
packets. Instead, the ACK frame is sent later together with a more urgent data. Frame types that
require immediate acknowledgments are called \textit{ack-eliciting frames}, and the packets with at
least one such frame are called \textit{ack-eliciting packets}.

Because packets in differnet packet number spaces offer different level of confidentiality, not all
frames can be sent in any packet type. For example, application data in \STREAM{} frames cannot be
sent in Initial and Handshake to avoid compromising security. \autoref{tab:02-frame-types} lists all
frame types, whether they are ack-eliciting and in which packets they can be sent.

\begin{myTable}[\small] {tab:02-frame-types} {QUIC frame types}
  {l@{\hskip -0.1in}ccccc}
  {                     &               & \multicolumn{4}{c}{Allowed in packet type} \\ \cmidrule(lr){3-6}
    Frame type          & Ack-eliciting & Initial & Handshake & 0-RTT & 1-RTT}
  \PADDING{}            &               & \checkmark{}     & \checkmark{}       & \checkmark{}   & \checkmark{}          \\
  \PING{}               & \checkmark{}           & \checkmark{}     & \checkmark{}       & \checkmark{}   & \checkmark{}          \\
  \ACK{}                &               & \checkmark{}     & \checkmark{}       &       & \checkmark{}          \\
  \RESETSTREAM{}        & \checkmark{}           &         &           & \checkmark{}   & \checkmark{}          \\
  \STOPSENDING{}        & \checkmark{}           &         &           & \checkmark{}   & \checkmark{}          \\
  \CRYPTO{}             & \checkmark{}           & \checkmark{}     & \checkmark{}       &       & \checkmark{}          \\
  \NEWTOKEN{}           & \checkmark{}           &         &           &       & \checkmark{}          \\
  \STREAM{}             & \checkmark{}           &         &           & \checkmark{}   & \checkmark{}          \\
  \MAXDATA{}            & \checkmark{}           &         &           & \checkmark{}   & \checkmark{}          \\
  \MAXSTREAMDATA{}      & \checkmark{}           &         &           & \checkmark{}   & \checkmark{}          \\
  \MAXSTREAMS{}         & \checkmark{}           &         &           & \checkmark{}   & \checkmark{}          \\
  \DATABLOCKED{}        & \checkmark{}           &         &           & \checkmark{}   & \checkmark{}          \\
  \STREAMDATABLOCKED{}  & \checkmark{}           &         &           & \checkmark{}   & \checkmark{}          \\
  \STREAMSBLOCKED{}     & \checkmark{}           &         &           & \checkmark{}   & \checkmark{}          \\
  \NEWCONNECTIONID{}    & \checkmark{}           &         &           & \checkmark{}   & \checkmark{}          \\
  \RETIRECONNECTIONID{} & \checkmark{}           &         &           & \checkmark{}   & \checkmark{}          \\
  \PATHCHALLENGE{}      & \checkmark{}           &         &           & \checkmark{}   & \checkmark{}          \\
  \PATHRESPONSE{}       & \checkmark{}           &         &           & \checkmark{}   & \checkmark{}          \\
  \CONNECTIONCLOSE{}    &               & \checkmark{}     & \checkmark{}       & \checkmark{}   & \checkmark{}          \\
  \HANDSHAKEDONE{}      & \checkmark{}           &         &           &       & \checkmark{}          \\
\end{myTable}

\todo{Short description of each packet type and what it is used for?}


\section{QUIC Connection}

\todo{expand this part} This section describes the details of connection lifetime.

\subsection{Connection ID}

Traditional network protocols use the combination of remote endpoint IP address and port to identify
the connection. QUIC, on the other hand, uses a dedicated Connection ID identifier. This in essence
enables migrating the connection to different network paths and interfaces, e.g. from cellular data
to a Wi-Fi network, because the connection identity does not depend on the peer's IP address.

Connection IDs are opaque byte sequences between 8 to 20 bytes in length. Each endpoint in a QUIC
connection independently selects Connection IDs it will use to identify the QUIC connection. These
Connection IDs are then used to populate the Source Connection ID and Destination Connection ID of
the QUIC packets.

The first pair of Connection IDs is exchanged during connection establishment. Additional Connection
IDs can be issued independently by each endpoint during the lifetime of the connection. These
additional Connection IDs are primarily used when migrating the connection to a new network path.
QUIC requires that the same Connection ID be used only on one network path. When migrating a
connection, the endpoints must start using different Connection ID for sending packets to prevent
correlation of the network traffic by external observers.

Connection IDs can be also retired by an endpoint. By retiring a Connection ID, the endpoint
communicates that it will no longer use the Connection ID, and the other endpoint should drop any
incoming packets that use it. Retiring a Connection ID serves as a request to the peer to issue a
new Connection ID as a replacement.

Alternatively, endpoints can use a zero-length Connection ID. In that case, the connection identity
is tied to the IP address and port of the remote endpoint. Using zero-length Connection ID saves
space in the sent datagrams, but imposes several limitations on the connection. For example, if an
endpoint uses a zero-length Connection ID, it cannot issue additional connection IDs and, therefore,
it cannot migrate a connection to a new local address.

\subsection{Matching Packets to Connections}

When a packet arrives to an endpoint, it needs to be associated with an existing connection, or ---
for servers --- potentially initiate a new connection. If packet contains a non-zero-length Connection
ID in the DCID field, the Connection ID is used to find an existing connection. If the packet uses a zero-length conneciton id, then the local and remote addresses determine the target connection.

\autoref{fig:02-connection-multiplexing} illustrates how server endpoint processes incoming packets
from client connections. Server maintains a table mapping between DCIDs corresponding connections,
and dispatches the incoming packets accordingly. If a packet cannot be associated with an existing
connection, then it may be a new connection attempt, otherwise the packet is discarded.

\begin{myFigure}{fig:02-connection-multiplexing}{Multiple QUIC connections on the same machine port}

\input{img/02-socket-multiplexing.pdf_tex}

\todo{Check if the image is more clear now}

\end{myFigure}

In case the packet cannot be associated with an existing connections, client endpoints simply ingore
the packet. Server, on the other hand, check the packet type and version of the protocol it
requires. For valid Initial packets with supported verions, server proceeds with the handshake as
described in the previous section. For invalid Initial packets, the server responds with an Initial
packet containing a \CONNECTIONCLOSE{} frame signaling the refusal of the connection.

In case the client packet requests an unsupported QUIC version, server replies with a Version
Negotiation packet (described in \autoref{sec:02-version-negotiation-packet}). After receiving such
a packet, the client can try again using one of the supported versions. Figure
\autoref{fig:02-version-negotiation-flow} illustrates such an exchange. In the figure, the client
tries to establish connection using an unsupported version denoted by X. Server then replies with
Version Negotiation packet listing versions 1,2, and 3. Client the tries to establish connection
again using the version 1.

\begin{myFigure}{fig:02-version-negotiation-flow}{Example Version Negotiation packet exchange}

\resizebox{\linewidth}{!}{\input{img/02-version-negotiation-flow.pdf_tex}}

\end{myFigure}

Lastly, the server may choose to send a Stateless Reset (see later in
\autoref{sec:02-stateless-reset}) for any other packet that cannot be matched to an existing
connection.

\subsection{QUIC Transport Parameters}\label{sec:02-transport-parameters}

QUIC has several options for parameterizing the connection. These are called \textit{Transport
  Parameters} and they essentially represent constraints for the other endpoint. Each endpoint sets
the transport parameters for the other endpoint. QUIC leverages the extensibility of the TLS
protocol to exchange transport parameters during the connection handshake.

\todo{should I mention them by name? e.g. I mention max\_idle\_timeout later}
Example transport parameters are:

\begin{itemize}

  \item Initial flow control limits

  \item Whether connection migration is allowed

  \item Maximum delay before sending an acknowledgment for ack-eliciting packets

  \item Maximum idle timeout before the connection is silently closed

  \item Maximum size of a UDP packet the endpoint is willing to receive

\end{itemize}

Many of the parameters have a default value, which is used when the given transport parameter is not
sent. Other transport parameters are mandatory. The exhaustive list of the transport parameters can be found in the core transport specification~\cite[Section~7.4]{draft-ietf-quic-transport}.

\subsection{Connection Establishment}

In order to initiate a new connection, clients sends an Initial packet to the server, which
initiates the handshake process. After the handshake completes, both peers have derived protection
keys necessary to send and receive 1-RTT packets with application data.

An example handshake flow is illustrated in \autoref{fig:02-example-handshake-flow}. The figure
shows client and server endpoints exchanging UDP datagrams with QUIC packets. For illustration, we
list the contents of the individual QUIC frames. The figure also lists contents of the \CRYPTO{}
frames sent. However, these are only for illustrative purposes because QUIC does not interpret the
\CRYPTO{} frames' contents.

\begin{myFigure} {fig:02-example-handshake-flow} {Example QUIC handshake flow}

\resizebox{\linewidth}{!}{\input{img/02-handshake-flow.pdf_tex}}

\end{myFigure}

In its first datagram, the client sends an Initial packet with initial information consisting of a
single \CRYPTO{}(CH) frame. This frame contains the \textit{Client Hello} TLS message.

The server replies with a datagram containing three coalesced QUIC packets. The first is an Initial
packet that acknowledges the client's Initial packet using the \ACK{}(0) frame, and a \CRYPTO{}(SH)
frame with a \textit{Server Hello} message. The contents of Client Hello and Server Hello messages
are used by TLS to derive Handshake protection keys. The server advances the TLS handshake further
by sending another \CRYPTO{} frame in the Handshake packet. The server also has enough information
to derive also the 1-RTT keys, so it can also start sending data on Stream 1 using the \STREAM{}(1,
``...'') frame in a 1-RTT packet.

Because the server's Initial packet contained an ack-eliciting \CRYPTO{}(SH) frame, the client needs
to acknowledge it by sending an Initial frame with an \ACK{}(0) frame. The client can posesses both
Client and Server Hello mesages and can derive the Handshake keys, enabling him to process the
server's Handshake packet. The Handshake packet needs to be separately acknowledged by another
\ACK{}(0) frame, and a reply from the TLS layer must be sent using another \CRYPTO{} frame. From the
information in the server's Handshake packet's \CRYPTO{} frame, the client derives 1-RTT protection
keys and processes the server's 1-RTT packet. In addition to sending an \ACK{}(0) frame for the
server's 1-RTT packet, the client can now start sending application data on stream 0 using a
\STREAM{}(0, ``...'') frame.

After server detects that Handshake has successfully completed, it sends a \HANDSHAKEDONE{} frame to
communicate the fact to the client.

\todo{retry? or do it as part of Security section?}

\subsection{Connection Termination}

QUIC connection can be terminated in three ways:

\begin{itemize}

  \item Idle timeout

  \item Immediate close

  \item Stateless reset

\end{itemize}

\subsubsection{Idle Timeout}\label{sec:02-idle-timeout}

If idle timeout is enabled, the endpoint silently closes the connection if it does not receive a
packet from the peer for a specified time period. Each peer may advertise a timeout period using the
\MaxIdleTimeout{} transport parameter, but the effective value is the minimum of the two
values.

In order to prevent timeouts, endpoints can send a \PING{} or another ack-eliciting frame to test
the liveness of the connection. However, sending \PING{} frames should be initiated by the
application protocol, not QUIC implementation, to prevent unnecessary network traffic.

\subsubsection{Immediate Close}

An immediate close can be initiated both by QUIC implementation and by the application protocol.
Either endpoint can initiate an immediate close by sending a \CONNECTIONCLOSE{} frame. By sending a
\CONNECTIONCLOSE{} frame, the peer enters a \textit{closing state}, in which it includes the
\CONNECTIONCLOSE{} frame in all packets it sends in reply to incoming packets. The closing state is
received also if the endpoint receives a \CONNECTIONCLOSE{} frame from the peer. In that case the
endpoint also echoes the \CONNECTIONCLOSE{} frame back to the other endpoint.

The closing state lasts until the endpoint is sure the other endpoint is also in the closing state ---
e.g., until it also receives \CONNECTIONCLOSE{} --- or until a \textit{closing timeout} expires. The
closing timeout period is calculated from the current estimate of the round-trip time of the
connection.

The \CONNECTIONCLOSE{} frame carries an error code and, optionally, a human-readable error phrase.
When initiated by QUIC, the error codes semantics defined by the QUIC specification. However, when
initiated by the application protocol, the semantics of all possible error code values sent in the
frame are defined by the application protocol itself. This implies that the implementations must
require an error code when closing the connection and do not provide a default error code value.

\subsubsection{Stateless Reset}\label{sec:02-stateless-reset}

A stateless reset is an option of last resort for an endpoint that does not have access to the state
of a connection, possibly resulting from a crash or outage. An endpoint may send a stateless reset
in response to receiving a packet that it cannot associate with an active connection.

In such cases, the endpoint sends a specially crafted packet that ends with a Stateless Reset Token
associated with his Connection ID\@. The Stateless Reset Token requirements are quite complex, and
we encourage readers to read the full specification if they are interested in details~\cite[Section~10.4]{draft-ietf-quic-transport}.

\subsection{Connection Migration}

A novel feature of QUIC is the ability to migrate connections to a different network path. This is
enabled by using a dedicated Connection ID, instead of using the endpoint's address to identify the
connection. In the initial QUIC versio, only client endpoints can migrate the connection to a
different address.

Prior to migrating a connection, the endpoint can optionally check the reachability of the other
endpoint using the process called \textit{path validation}. Path validation consists of exchanging
\textit{probing packets}, and is described in \autoref{sec:02-path-validation}.

If the path is validated, the endpoint can migrate the connection by starting to send packets from
the mew local address. After server receives the first non-probing packet from the new client's
address, it starts sending all future packets to that new address.

In order to prevent network traffic being correlated by the outside observers, QUIC requires each
Connection ID to be used for only one combination of local and remote endpoint addresses. Therefore,
when connection is migrated, both endpoints must switch to using different Connection IDs.

The connection migration process is illustrated in \autoref{fig:02-connection-migration-flow}.
Client and servers use Connection IDs \textbf{C1} and \textbf{S1}, respectively. Client first probes
the reachability of the server with a probing packet containing a \PATHCHALLENGE{} frame. Because
this packet is sent from a different local address, it uses a different Connection ID (\textbf{S2})
that was issued previously by the server. Likewise, server uses different Connection ID \textbf{C2}
to reply with a packet containing a \PATHRESPONSE{} frame, confirming the reachability from the
clients new local address. After that, client migrates the connection by sending all packets via the
new local address. After receiving next non-probing packet from the new address, server switches to
the new client's address as well. Connection IDs \textbf{C1} and \textbf{S1} are no longer used in
the rest of the connection and can be retired later.

\begin{myFigure}{fig:02-connection-migration-flow}{Flow of packets during connection migration}

\resizebox{\linewidth}{!}{\input{img/02-connection-migration-flow.pdf_tex}}

\end{myFigure}

\section{QUIC Streams}

QUIC can transport multiple streams of data in a single connection. Each stream is identified by its
\textit{Stream ID} and is processed independently of the other streams. Each QUIC packet can carry
data for one or more QUIC streams. \autoref{fig:02-stream-multiplexing} illustrates how QUIC may
pack two streams into frames such that those streams are transported in parallel.

\begin{myFigure}{fig:02-stream-multiplexing}{Stream multiplexing in QUIC}

  \input{img/02-stream-multiplexing.pdf_tex}

\end{myFigure}

\subsection{Streams Types}

Streams transported by QUIC can be either unidirectional or bidirectional. Unidirectional streams
carry data from the initiator to its peer, and bidirectional streams carry data in both directions.
Both client and server can open new streams. QUIC recognizes four types of streams, and the type of
the stream is encoded in the two least significant bits of the Stream ID. The stream types and their
associated encoding is summarized in \autoref{tab:02-stream-id-type-map}.

\begin{myTable} {tab:02-stream-id-type-map} {Mapping of QUIC Stream types to Stream ID bits}
  {cc}
  {Stream type                     & Least significant bits}
  Client-Initiated, Bidirectional  & \binary{0} \\
  Server-Initiated, Bidirectional  & \binary{1} \\
  Client-Initiated, Unidirectional & \binary{2} \\
  Server-Initiated, Unidirectional & \binary{3} \\
\end{myTable}

Bidirectional streams can be viewed as the combination of two unidirectional streams. After opening
the stream, each direction of the stream behaves as separate inbound and outbound unidirectional
streams. This implies that the sending and receiving part of the stream can be closed independently
of each other.

\subsection{Stream Lifetime}

Opening a stream does no require any special action. Streams are opened simply by sending the first
\STREAM{} frame carrying data for that stream. However, streams of a particular type can be opened
only in ascending order of their Stream IDs. For example, stream with ID 2 must be opened before
opening stream 6. Sending data for higher numbered streams will automatically open all lower
numbered streams of the same stream type.

Streams can be closed either gracefully or abortively. Graceful stream close is signaled by a
\textit{Fin} bit in the \STREAM{} frame, signaling that data carried by this packet are the last
part of the stream. The stream is gracefully closed once all stream data is confirmed received by
the other endpoint.

Abortive stream close is achieved using the \RESETSTREAM{} frame and, therefore, this action is also
reffered to as \textit{resetting the stream}. Streams can be reset only by the sender. Receiver can
request abortive stream close by sending a \STOPSENDING{} frame if it no longer wishes to receive
data on that stream. Both \RESETSTREAM{} and \STOPSENDING{} frames carry an application-level error
code, that is then read by the application using QUIC.

After the stream is closed, it's Stream ID cannot be reused. Instead, the next available Stream ID
must be used. QUIC uses the variable-length integer encoding (see
\autoref{sec:02-variable-length-encoding}) and, therefore, there is no shortage of available stream
IDs, which range from 0 to $2^{62}-1$.

\subsection{Required Operations on Streams}

The implementation should provide the following operations on sending part of the stream:

\begin{itemize}

  \item write data;

  \item end the stream by specifying that all data has been written; and

  \item terminate the stream with an application-level error code.

\end{itemize}

On receiving part of the stream, application protocols must to be able to:

\begin{itemize}

  \item read data; and

  \item abort reading with an application-level error code.

\end{itemize}

\section{Flow Control}

QUIC aims to be a general-purpose transport protocol to be used over a potentially untrusted
network, and as such, it needs to protect endpoints from malicious peers. To prevent malicious
senders from exhausting all available memory on the receiver by sending large amounts of data, or
fast senders from overwhelming slow receivers, QUIC employs a credit-based flow control scheme.

All QUIC streams are flow controlled both individually and together as an aggregate. Each endpoint
also controls the number of streams the other peer is allowed to open. All flow control limits are
communicated to the peer using three types of frames:

\begin{itemize}

\litem{\MAXSTREAMDATA{}} maximum offset of data sent on a stream with specified ID\@.

\litem{\MAXDATA{}} maximum sum of all offsets of data sent on all streams.

\litem{\MAXSTREAMS{}} maximum number of opened streams of a particular stream type.

\end{itemize}

Endpoints can only increase the flow control limits. Their peers must ignore any attempts to
decrease the flow control limits to ensure consistency when two consecutive QUIC packets with flow
control updates are reordered during transit. In case the peer violates any of the control flow
limits mentioned above, the QUIC implementation must immediately terminate the connection.

\section{Loss Detection and Recovery}

Because UDP is an unreliable transport protocol, QUIC must implement measures to recover from packet
loss. The packet loss detection is implemented similarly to TPC --- each endpoint sends
acknowledgments for each received packet. However, an essential difference from TCP is that QUIC
endpoints do not retransmit entire lost packets using the same packet number. Instead, each QUIC
frame in the original packet is updated and sent in some future packet, or dropped altogether if the
information contained in the frame is no longer relevant.

The acknowledgement is communicated using the \ACK{} frame which contains ranges of received packet
numbers that the endpoint acknowledges. A packet number can sent multiple times (in \ACK{} frames in
multiple packets) until the endpoint can determine that the other endpoint received the
acknowledgement.

For packets containing an \textit{ack-eliciting} frame (see \autoref{sec:02-quic-frames}),
acknowledgements must be sent before the delay specified by the \MaxAckDelay{} transport
parameter. For other packets, such as packets containing only \ACK{} or \PADDING{} frames, the
acknowledgement can be delayed until an ack-eliciting packet is received.

\autoref{fig:02-packet-loss-example} illustrates the loss detection and retransmission process in
action. When server receives the acknowledgment for packet 3, but not for packet 2 sent earlier, it
infers that packet 2 never reached the receiver and retransmits the payload \textbf{B} in packet 4.
The server does not have to retransmit the \ACK{} for packet 1 because it was already sent in packet
3 which was already acknowledged by the client. Therefore, packet 4 includes ACK only for packet 2.

\begin{myFigure}{fig:02-packet-loss-example}{Loss detection and retransmission example}

\input{img/02-retransmission-example.pdf_tex}

\end{myFigure}

The exact criteria for a packet to be deemed lost by a QUIC endpoint are following:

\begin{enumerate}

  \item The packet was not acknowledged.

  \item A packet which was sent later has been acknowledged.

  \item Either the packet has been sent long enough in the past, or its packet number is
sufficiently smaller than the highest acknowledged packet number.

\end{enumerate}

The third condition is dependent on the values of particular constants. The specification recommends
that the packet is considered lost if the gap between its packet number and the highest acknowledged
packet number is at least 3, or if it was sent for longer than $9/8$ times the estimate of the
current round-trip time.

The first condition mentioned above requires receipt of a packet from the peer to declare any packet
as lost. However, the loss of the last packet in a sequence could go undetected because there is no
following packet that can be acknowledged. To avoid possible deadlocks in such scenarios, QUIC
endpoint sends up to two ack-eliciting \textit{probe packets} if it does not receive a packet from a
peer in a period called \textit{probe timeout} (PTO for short). The PTO duration doubles each time
probe packets are sent until either a reply is received or the connection is terminated due to idle
timeout (see \autoref{sec:02-idle-timeout})

Similarly to TCP, QUIC also uses congestion control to manage the \textit{congestion window} --- the
amount of data that can be in-flight. The selection of the congestion control algorithm is left on
the implementation. As an example, The QUIC specification document for loss detection and recovery~\cite[Section~7]{draft-ietf-quic-recovery} describes a congestion control algorithm similar to TCP NewReno~\cite{rfc6582} algorithm.

\section{Security}

This section describes the mechanisms used to ensure security of the protocol. Besides encrypting
all packets sent throughout the lifetime of the connection, QUIC uses additional mechanisms to
ensure that the servers using the protocol are resistant to denial-of-service and other
cyber-attacks.

\subsection{TLS Integration}

Instead of designing a new handshake protocol, QUIC offloads the encryption negotiation to TLS
protocol (more precisely, TLS version 1.3). The low-level messages used in TLS, such as
\textit{Server Hello} and \textit{Client Hello} are transported by QUIC inside \CRYPTO{} frames and
passed to a TLS implementation on the other side. This way, QUIC is able to offer the same
confidentiality level as conventional TLS connections.

The TLS protocol is extensible, among the standard extensions which are also used by QUIC are
Application Level Protocol Negotiation~\cite{rfc7301} (ALPN for short) and Server Name
Indication~\cite{rfc6066} (SNI for short).

Application Level Protocol Negotiation is used when multiple application protocols are supported on
the same TCP or UDP port. ALPN allows the application layer to negotiate --- as part of the TLS
handshake --- which application protocol will be used in the established connection.

Server Name Indication is used by clients to specify the hostname of the server to which they are
connecting. When multiple websites are hosted on the same IP address and port, SNI allows the server
to customize the security configuration for each hosted website. During connection establishment,
proper security configuration, such as the SSL certificate to be used, can be selected based on the
value of the hostname.

A custom TLS extension is used by QUIC to exchange transport parameters during the handshake. The
transport parameters are described in \autoref{sec:02-transport-parameters}.

\subsection{Packet Protection}\label{sec:02-packet-protection}

All QUIC packets of type Initial, Handshake, 1-RTT and 0-RTT are encrypted to ensure integrity and
confidentiality of the transmitted data. Negotiation of the cryptographic ciphers and the encryption
keys is handled by the TLS handshake. This section focuses on how the negotiated encryption is
applied to QUIC packets.

\subsubsection{Authenticated Encryption with Associated Data}

QUIC uses type of encryption called Authenticated encryption with associated data~\cite{rfc5116}
(AEAD for short). This type of encryption ensures both confidentiality and authenticity of the
encrypted data. In addition to encrypted data --- called \textit{ciphertext} --- AEAD encryption
outputs also an authentication tag which is used to check the integrity of the payload during
decryption. The encryption can be authenticated by supplying additional authentication data (AAD for
short) which are not encrypted, but influence the authentication tag and, therefore, must be
supplied also during decryption. As an additional protection, AEAD also accepts a \textit{nonce}
parameter, which is an additional input which is supposed to be unique for each encrypted packet.

The programming interface for AEAD provides following operations:

\begin{itemize}

  \item Encryption:

  \begin{itemize}

    \item input: plaintext, key, nonce, AAD (optional)

    \item output: ciphertext, authentication tag

  \end{itemize}

  \item Decryption:

  \begin{itemize}

    \item input: ciphertext, key, nonce, authentication tag, AAD (if provided during encryption)

    \item output: plaintext or error if the authentication tag does not match the supplied
      ciphertext and AAD

  \end{itemize}

\end{itemize}

\subsubsection{Deriving QUIC Protection Keys}\label{sec:02-encryption-key-derivation}

QUIC derives multiple distinct keys from the secrets negotiated by TLS handshake. The derivation
uses the HKDF-Expand-Label function~\cite{rfc5869} to derive keys of desired length. The keys are
derived as follows:

\begin{equation*}
  \begin{split}
  key & = \operatorname{HKDF-Expand-Label}(secret, \texttt{"quic key"}, \texttt{""}, 32) \\
  iv  & = \operatorname{HKDF-Expand-Label}(secret, \texttt{"quic iv"}, \texttt{""}, 12)  \\
  hp  & = \operatorname{HKDF-Expand-Label}(secret, \texttt{"quic hp"}, \texttt{""}, 32)  \\
  \end{split}
\end{equation*}

The following subsections describe how the $key$, $iv$, and $hp$ keys are used in the actual process
of packet encryption.

\subsubsection{Packet Protection Procedure}

When actually encrypting the packets, QUIC first encrypts the packet payload using the AEAD cipher
negotiated by the TLS implementation. QUIC specification allows use of all AEAD ciphers allowed in
TLS 1.3. These ciphers are:

\begin{itemize}

  \item TLS\_AES\_128\_GCM\_SHA256

  \item TLS\_AES\_256\_GCM\_SHA384

  \item TLS\_CHACHA20\_POLY1305\_SHA256

  \item TLS\_AES\_128\_CCM\_SHA256

  \item TLS\_AES\_128\_CCM\_8\_SHA256

\end{itemize}


The parameters for AEAD for packet payload protection are:

\begin{itemize}

    \litem{key} the $key$ derived in previous section

    \litem{nonce} the $iv$ derived in previous section, last 8 bytes XORed with the packet number

    \litem{AAD} the contents of the packet header

    \litem{plaintext} the payload of the packet.

\end{itemize}

The produced authentication tag is appended to the protected payload and is included in the payload
size.

QUIC also protects the header of the packet. The header protection mechanism is more complex than
that of the payload. The process requires calculating the \textit{header protection mask}, which is
then applied using XOR to parts of the packet header. The details of the header protection mask
calculation depend on the negotiated cipher, but it always uses the $hp$ key and a 16-byte sample of
the encrypted payload.

The parts of the packets protected by the payload encryption and header
protection mechanisms are illustrated in \autoref{fig:02-protected-fields}.


\begin{myFigure}{fig:02-protected-fields}{Fields protected by payload encryption and header protection}

  \newcommand{\legendsquare}[1]{%
    \textcolor{#1}{\rule{0.7em}{0.7em}}%
  }

  \definecolor{hp}{rgb}{0.7, 1, 0.7}
  \definecolor{pp}{rgb}{0.7, 0.7, 1}

  \legendsquare{hp}~Header protection \hspace{1cm} \legendsquare{pp}~Payload encryption

  \vspace{5mm}

  \begin{mySubFigure}{\textwidth}{fig:02-protected-fields-long}{Long header packets}

    \begin{bytefield}[bitwidth=2.5em]{8}
      \bitheader{0-7} \\
      \begin{rightwordgroup}{long \\ header}
        \bitbox{1}{H=1} & \bitbox{1}{F=1} & \bitbox{2}{T (2)} & \colorbitbox{hp}{2}{R=\binary{0}} & \colorbitbox{hp}{2}{L (2)} \\
        \wordbox[tlrb]{\longFieldHeight}{Version (32)} \\
        \wordbox[tlrb]{1}{Destination Connection ID Length (8)} \\
        \wordbox[tlrb]{\longFieldHeight}{Destination Connection ID (0..160) } \\
        \wordbox[tlrb]{1}{Source Connection ID Length (8)} \\
        \wordbox[tlrb]{\longFieldHeight}{Source Connection ID (0..160) }
      \end{rightwordgroup} \\
      \begin{leftwordgroup}{Initial \\ only}
        \colorbitbox{bytefieldunused}{8}{Token Length (i)} \\
        \colorwordbox{bytefieldunused}{tlrb}{\longFieldHeight}{Token (..)}
      \end{leftwordgroup} \\
      \wordbox[tlrb]{1}{Length (i)} \\
      \colorwordbox{hp}{ltrb}{\longFieldHeight}{Packet Number (8..32)} \\
      \colorwordbox{pp}{tlrb}{\longFieldHeight}{Packet Payload (..)} \\
      \wordbox[tlrb]{\longFieldHeight}{Integrity Tag (16)} \\
    \end{bytefield}

  \end{mySubFigure}

  \vspace{5mm}

  \begin{mySubFigure}{\textwidth}{fig:02-protected-fields-short}{Short header packets}

    % this one has to be off-center to make the image aligned with the top one
    \hspace{1.8cm}\begin{bytefield}[bitwidth=2.5em]{8}
      \bitheader{0-7} \\
      \begin{rightwordgroup}{short \\ header}
        \bitbox{1}{H=0} & \bitbox{1}{F=1} & \bitbox{1}{S} & \colorbitbox{hp}{2}{R=\binary{0}} & \colorbitbox{hp}{1}{K} & \colorbitbox{hp}{2}{L (2)} \\
        \wordbox[tlrb]{\longFieldHeight}{Destination Connection ID (0..160) }
      \end{rightwordgroup} \\
      \colorwordbox{hp}{ltrb}{\longFieldHeight}{Packet Number (8..32)} \\
      \colorwordbox{pp}{tlrb}{\longFieldHeight}{Packet Payload (..)} \\
      \wordbox[tlrb]{\longFieldHeight}{Integrity Tag (16)} \\
    \end{bytefield}

  \end{mySubFigure}

\end{myFigure}

\subsubsection{Updating 1-RTT Protection Keys}\label{sec:02-key-update}

Some AEAD functions have limits for how many packets can be encrypted using the same keys. Analysis
in the specification document shows that updating the protection keys after sending at most $2^{23}$
packets provides the same confidentiality level as a standard TLS
connection~\cite[Appendix~B]{draft-ietf-quic-tls}.

The key update is signalled by flipping a \textit{Key Phase} bit in the 1-RTT packet header. And
after observing the change in the \textit{Key Phase}, an endpoint derives new secret and $key$ and
$iv$ keys using the HKDF-Expand-Label function:

\begin{equation*}
  \begin{split}
  secret_{n+1} & = \operatorname{HKDF-Expand-Label}(secret_{n}, \texttt{"quic ku"}, \texttt{""}, 32) \\
  key_{n+1} & = \operatorname{HKDF-Expand-Label}(secret_{n+1}, \texttt{"quic key"}, \texttt{""}, 32) \\
  iv_{n+1}  & = \operatorname{HKDF-Expand-Label}(secret_{n+1}, \texttt{"quic iv"}, \texttt{""}, 12)  \\
  \end{split}
\end{equation*}

Because the \textit{Key Phase} bit is protected by header protection, the $hp$ key must remain
unchanged to ensure that the other endpoint can correctly remove the header protection.

\subsection{Client Address Validation}\label{sec:02-address-validation}

After receiving the first Initial packet from a new client, server can request address validation by
sending a Retry packet (see \autoref{sec:02-retry-packet}). The Retry packet carries a token which
must be echoed back to the server in all following Initial packets. As long as an attacker cannot
generate a valid token for its address and the client is able to return that token, this exchange
proves to the server that the client has received the token.

\autoref{fig:02-client-address-validation-flow} illustrates the use of Retry packet to valididate
client address during connection establishment. By default, clients do not fill the Token field of
the Initial packet. The server rejects the initial connection attempt and issues a Retry Token
(denoted ``ABCD'' in the figure). Client then tries again with another Initial with the provided
token and the server proceeds with the usual handshake.

\begin{myFigure}{fig:02-client-address-validatin-flow}{Client address validation using a Retry packet.}

\resizebox{\linewidth}{!}{\input{img/02-client-address-validation-flow.pdf_tex}}

\end{myFigure}

\subsection{Path Validation}\label{sec:02-path-validation}

QUIC is layered on top of UDP which is a connection-less protocol. This means that changes in
endpoint address can also happen without active migration on the endpoint's part, e.g., because of
NAT rebinding along the network path.

The endpoint address may also be spoofed by the other endpoint in an attempt to perform
\textit{traffic amplification attack} against the spoofed address. For this reason, the amount of
data sent to the new endpoint address must be limited until path validation determines that the
address belongs to the endpoint. This path validation is performed by sending a \textit{probing
  packet} containing a \PATHCHALLENGE{} frame with an unpredictable token. The other endpoint must
echo the token back in a \PATHRESPONSE{} frame. After that the new address is considered validated
and the sending rate restrictions are lifted.
