\chapter{Developer Documentation}

The Managed QUIC implementation developed in this thesis is contained in a fork of the official
\dotnet{} runtime repository. The source code of this fork is attached in \todo{path to the src in
  attachments.}.

The documentation inside the \dotnet{} runtime repository contains detailed workflow instructions
necessary for \dotnet{} runtime development. These instructions explain the necessary
prerequisities, how to build the product and run tests. The top-level file of the workflow
instructions is located at \filename{docs/workflow/README.md}.

This chapter will focus on the \filename{System.Net.Quic} library which contains the QUIC protocol
implementation. The source code for this library is located inside the
\filename{src/dotnet-runtime/src/libraries/System.Net.Quic/} directory of the \dotnet{} runtime
codebase. The directory listing in \autoref{lst:05-system-net-quic-structure} shows the structure of
the \filename{System.Net.Quic} project directory. The listing also emphasises the \filename{Managed}
and \filename{UnitTests} directories which contain the code developed as part of this thesis. These
directories are the main focus of this chapter.

\newcommand{\mydtcomment}[1]{\DTcomment{#1}}
% use smaller width to make the tree more compact
\DTsetlength{0.2em}{0.6em}{0.2em}{0.4pt}{1.6pt}
\renewcommand{\DTstylecomment}[1]{{\footnotesize\rmfamily #1}}
\renewcommand{\DTstyle}[1]{{\footnotesize\texttt{#1}}}
\definecolor{dtemphcolor}{rgb}{0,0,0.75}
\newcommand{\dtemph}[1]{\textcolor{dtemphcolor}{\emph{#1}}}

\begin{myListing}[Directory structure of the System.Net.Quic project.]{lst:05-system-net-quic-structure}{Directory structure of the System.Net.Quic project. Emphasised items contain the implementation developed in this thesis.}
\dirtree{%
  .1 {src/dotnet-runtime/src/libraries/System.Net.Quic/}.
  .2 {ref}\mydtcomment{Refererence assembly code}.
  .2 {src}\mydtcomment{Main library source code}.
  .3 {Resources}.
  .4 {Strings.resx}\mydtcomment{Definition of localizable strings like exception messages.}.
  .3 {System}.
  .4 {Net}.
  .5 {Quic}.
  .6 {Implementations}\mydtcomment{Root directory for all QUIC implementations}.
  .7 {\dtemph{Managed}}\mydtcomment{\dtemph{This thesis' implementation sources}}.
  .7 {MsQuic}\mydtcomment{\libmsquic{}-based implementation sources}.
  .7 {Mock}\mydtcomment{Mock implementation used only in tests}.
  .6 {Interop}\mydtcomment{Imports from native libraries}.
  .3 {System.Net.Quic.csproj}.
  .2 {tests}\mydtcomment{Library tests source code}.
  .3 {certs}\mydtcomment{X.509 certificates used in tests}.
  .4 {cert.crt}\mydtcomment{Public certificate file}.
  .4 {cert.key}\mydtcomment{Private key file}.
  .3 {FunctionalTests}\mydtcomment{Tests against the public API}.
  .4 {System.Net.Quic.Functional.Tests.csproj}.
  .3 {\dtemph{UnitTests}}\mydtcomment{\dtemph{Managed implementation unit tests}}.
  .4 {\dtemph{System.Net.Quic.Unit.Tests.csproj}}.
  .2 {Directory.Build.props}.
  .2 {System.Net.Quic.sln}.
}
\end{myListing}

\section{QUIC Implementation Providers}

The \filename{System.Net.Quic} project internally contains an infrastructure for switching between
multiple implementations of the QUIC protocol. The API classes themselves are \keyword{sealed} but
they delegate all methods to polymorphic \textit{implementation providers}. Each \QuicListener{},
\QuicConnection{}, and \QuicStream{} instance contains a reference to a \QuicListenerProvider{},
\QuicConnectionProvider{}, or \QuicStreamProvider{} instance, respectively. Implementations of each
provider are provided by each QUIC implementation in the \filename{System.Net.Quic} library. Figure
\autoref{fig:05-quic-impl-providers} illustrates this indirection layer using a class diagram.

\begin{myFigure}{fig:05-quic-impl-providers}{Implementation providers for the QUIC API classes}

\resizebox{0.95\linewidth}{!}{\input{img/05-quic-implementation-providers.pdf_tex}}

\end{myFigure}

Creation of new \QuicListener{} and \QuicConnection{} instances is implemented using the
\gls{abstract-factory}~\cite{wiki:abstract-factory-pattern}. There are multiple implementations of
\QuicImplementationProvider{} class, one for each QUIC implementation. Instances of
\QuicImplementationProvider{} class are available as static properties of the
\class{QuicImplementationProviders} static class.

There were two pre-existing providers in the \filename{System.Net.Quic} project. Implementation of
these two providers is not the primary focus of this text and, therefore, this text will not provide
further details on these providers:

\begin{itemize}

  \litem[]{\texttt{MsQuic}} QUIC implementation backed by \libmsquic{} native library

  \litem[]{\texttt{Mock}} A mock QUIC implementation for use in tests

\end{itemize}

This thesis provides following two new provideres:

\begin{itemize}

  \litem[]{\texttt{Managed}} Managed implementation with TLS backed by \libopenssl{} fork with QUIC enabling API.

  \litem[]{\texttt{ManagedMockTls}} Managed implementation with mock TLS implementation, which does not depend on external libraries, but cannot interoperate with other QUIC implementations.

\end{itemize}

Additionally, there is the \texttt{Default} provider which in our implementation redirects to
\texttt{Managed}, but can be redirected to other implementations by setting
\texttt{DOTNETQUIC_PROVIDER} environment variable to the desired provider name.

The \QuicListener{} and \QuicConnection{} classes have a constructor overload which accepts an
instance of the \QuicImplementationProvider{} to be used. This way, the QUIC implementation can be
selected during runtime. This also allows reusing a suite of functional tests for all
implementations by simply changing the implementation provider.

\section{Managed QUIC Implementation Overview}

The source code for the managed implementation developed in this thesis is located under the
\filename{System.Net.Quic/src/System/Net/Quic/Implementations/Managed/} subdirectory.
\autoref{lst:05-managed-quic-structure} outlines the directory structure of the implementation.

\begin{myListing}{lst:05-managed-quic-structure}{Directory structure of the managed QUIC implementation}
\dirtree{%
  .1 {System.Net.Quic/src/System/Net/Quic/Implementations/Managed}.
  .2 {Internal}\mydtcomment{Internal code of the implementation}.
  .3 {Crypto}\mydtcomment{Cryptographic facilities}.
  .3 {Frames}\mydtcomment{Definition of QUIC frames}.
  .3 {Headers}\mydtcomment{Definition of QUIC packet headers}.
  .3 {Packets}\mydtcomment{QUIC packet number spaces handling}.
  .3 {Parsing}\mydtcomment{Parsing of QUIC primitives}.
  .3 {Recovery}\mydtcomment{Loss detection and recovery}.
  .3 {Sockets}\mydtcomment{Servicing socket IO}.
  .3 {Streams}\mydtcomment{Stream buffering}.
  .3 {Tls}\mydtcomment{TLS integration}.
  .4 {Mock}\mydtcomment{Mock TLS implementation}.
  .4 {OpenSsl}\mydtcomment{OpenSSL TLS integration}.
  .3 {Tracing}\mydtcomment{Tracing and logging facilities}.
  .2 {ManagedQuicConnection.cs}\mydtcomment{Implementation of public API}.
  .2 {ManagedQuicConnection.Frames.cs}\mydtcomment{Processing of QUIC frames}.
  .2 {ManagedQuicConnection.Packets.cs}\mydtcomment{Processing of QUIC packets}.
  .2 {ManagedQuicConnection.Recovery.cs}\mydtcomment{Handling packet loss}.
  .2 {ManagedQuicConnection.Stream.cs}\mydtcomment{Stream management}.
  .2 {ManagedQuicImplementationProvider.cs}\mydtcomment{Abstract factory implementation}.
  .2 {ManagedQuicListener.cs}\mydtcomment{Implementation of public API}.
  .2 {ManagedQuicStream.cs}\mydtcomment{Implementation of public API}.
}
\end{myListing}

The implementation is exposed using the \ManagedQuicListener{}, \ManagedQuicConnection{},
\ManagedQuicStream{} implementation provider classes and the \ManagedQuicImplementationProvider{}
factory. The source code for these classes can be found in the root directory of the implementation.

The high-level architecture has been described in \autoref{sec:03-high-level-architecture}. This and
following sections will provide further implementation details. The class diagram in
\autoref{fig:05-high-level-class-diagram} shows the releationship between the key architecture
classes which were also mentioned in \autoref{fig:03-architecture} and
\autoref{fig:03-socket-context-architecture}. These classes are:

\begin{itemize}

  \litem[]{\ManagedQuicConnection{}} Implementation provider for \QuicConnection{}. Implements stateful connection logic.

  \litem[]{\ManagedQuicListener{}} Implementation provider for \QuicListener{}. Maintains a queue of incomming connections to be accepted by the application.

  \litem[]{\QuicConnectionContext{}} Class hosting the background thread for servicing a single \ManagedQuicConnection{}, including timeout expiration and sending or receiving UDP datagrams with QUIC packets.

  \litem[]{\QuicSocketContext{}} Abstract class handling basic sending and receiving of UDP datagrams, base class for \QuicClientSocketContext{} and \QuicServerSocketContext{}.

  \litem[]{\QuicServerSocketContext{}} Implements server-side stateless UDP datagram processing and dispatch of incoming UDP datagrams to appropriate \QuicConnectionContext{} instance.

  \litem[]{\QuicClientSocketContext{}} Implements client-side \QuicSocketContext{} behavior, passing all packets to a single single \QuicConnectionContext{}.

\end{itemize}

\begin{myFigure}{fig:05-high-level-class-diagram}{Relationship between key classes of managed QUIC implementation}

\resizebox{\linewidth}{!}{\input{img/05-high-level-class-diagram.pdf_tex}}

\end{myFigure}

\section{Supporting Data Structures}

The QUIC implementation requires a few specialized data structures for internal implementation.

\subsection{RangeSet}

Efficient representation of acknowledged ranges of packet numbers and maintaining information about
which parts of the QUIC stream have been sent or acknowledged require a data structure capable of
efficiently performing set operations on ranges of integers. The \RangeSet{} class represents such a
set.

It is expected that the number of ranges in one \RangeSet{} instance will be rather small. Therefore
our implementation uses a sorted \ListOf{\class{T}} instance to store individual ranges. The ranges
themselves are represented by \class{RangeSet.\allowbreak{}Range} struct which contains the first and last
element represented by the range.

\subsection{PacketNumberWindow}

\todo{a figure was added, reread entire subsection}

The \PacketNumberWindow{} class is used to test if QUIC packet the given packet number has already
been received. Internally, it contains two 64-bit \keyword{ulong} fields: a bitmask marking the
received packet numbers and the offset of the window. All packet numbers above the window are
considered not received, all packet numbers below the window are considered received. Packet number
inside the window are considered received if the corresponding bit is set to 1. When a new packet
number is received, the window is shifted, if necessary, and the corresponding bit is set.

\autoref{fig:05-packet-number-window} illustrates how concept on an 8-bit window. \autoref{fig:05a}
shows the state of the \PacketNumberWindow{} after receiving packets 0--5. When packet 10 is
received, the window is shifted by 3 so that the highest bit corresponds to the packet number 10 and
is set to 1, as shown in \autoref{fig:05b}. \autoref{fig:05c} shows the state of the
\PacketNumberWindow{} when 15 is received next. The window needs to be shifted by another 5, moving
some unreceived packet numbers outside the window (marked by red color).

\begin{myFigure}{fig:05-packet-number-window}{Maintaining window of received packet numbers}

  \begin{mySubfigure}{\textwidth}{fig:05a}{State after receiving packets 0--5}
    offset = 0\hspace{1cm}...\texttt{\textcolor{colorunimportant}{00000000000000}\fbox{00111111}}
  \end{mySubfigure}

  \medskip

  \begin{mySubfigure}{\textwidth}{fig:05b}{State after receiving packet 10}
    offset = 3\hspace{1cm}...\texttt{\textcolor{colorunimportant}{00000000000}\fbox{10000111}\textcolor{colorunimportant}{111}}
  \end{mySubfigure}

  \medskip

  \begin{mySubfigure}{\textwidth}{fig:05c}{State after receiving packet 15}
    offset = 8\hspace{1cm}...\texttt{\textcolor{colorunimportant}{000000}\fbox{10000100}\textcolor{red}{11}\textcolor{colorunimportant}{111111}}
  \end{mySubfigure}

\end{myFigure}

The last part of the figure above demonstrates that the data structure may falsely label some old
packet numbers as already received. In such a case the packets are simply discarded by the
\ManagedQuicConnection{}. For this to happen, at least 64 other packets must be correctly received.
However, the tollerance of the loss detection algorithm outlined in \autoref{sec:02-loss-detection}
allows only significantly smaller packet reordering. The specification suggests maximum reordering
tollerance of 3, meaning that receiving a packet number should mark all packets as lost except the
previous two. Therefore, it is very likely that any newly received packet with packet number under
the window maintained by the \PacketNumberWindow{} instance is already considered lost by the sender
and its data have been retransmitted in a different packet. Thus the width of 64 of the packet
number window is sufficient.

\section{ManagedQuicConnection Implementation}

The \ManagedQuicConnection{} class implements the stateful QUIC connection logic which makes up most
of the managed QUIC implementation. The source code of the \ManagedQuicConnection{} class is
separated by area into multiple files, as outlined previously in
\autoref{lst:05-managed-quic-structure}:

\begin{itemize}

  \litem{Public API} Implementation of the public API methods inherited from the \QuicConnectionProvider{} class.

  \litem{Packets} Processing individual QUIC packets, applying and removing the packet protection, generating packets to be sent.

  \litem{Frames} Processing individual QUIC frames, and generating frames for outgoing packets.

  \litem{Stream} Management of created QUIC streams and flow control limits.

  \litem{Recovery} Tracking of sent QUIC packets, handling of acknowlegements and packet loss. Congestion window management.

\end{itemize}

Following subsections describe the major parts of the implementation.

\subsection{Integration with Socket Management}

The \ManagedQuicConnection{} implementation is separated from socket IO management. Also, to allow
for deterministic unit testing, the implementation does not maintain an internal timer that would
automatically invoke some logic on expiration. Instead, all interactions with a \Socket{} are driven
externally by a \QuicConnectionContext{} class which maintains a background processing thread for
handling timeouts and sending and receiving of QUIC packets. The interface used by
\QuicConnectionContext{} consists of following members on \ManagedQuicConnection{}:

\begin{description}

  \ditemproperty[\enum]{QuicConnectionState}{ConnectionState}{\propget} The current state of the connection. Used to detect transitions to, e.g., connected state or closed state.

  \ditemmethod[\keyword]{void}{SendData}{\QuicWriter{}, \keyword{out} \class{EndPoint}, \class{QuicSocketContext.SendContext}}
  Allows the connection to write a UDP datagram to be sent into the \QuicWriter{} instance and specify the \class{EndPoint} to which the UDP datagram should be sent. The \class{SendContext} instance contains additional data like the current timestamp.

  \ditemmethod[\keyword]{void}{ReceiveData}{\QuicReader{}, \class{EndPoint}, \class{QuicSocketContext.RecvContext}}
  Processes a datagram from the provided \QuicReader{} instance. The \class{Recv\allowbreak{}Context} instance contains additional data like current timestamp.

  \ditemmethod[\keyword]{long}{GetNextTimerTimestamp}{}
  Retrieves the timestamp when the next internal timer of expires. Examples of such timer are loss detection timer, draining timer before closing the connection, or pacing timer for evening out the outbound packet flow. When the timer expires, the \ManagedQuicConnection{} instance may have more data to send.

\end{description}

The value of \method{GetNextTimerTimestamp} is then used to suspend the background processing thread
in order not to consume CPU resources. The background processing thread waits until either the timer
expires using \texttt{\class{Task}.\method{Delay}()} or until a new QUIC packet arrives. However,
some application code actions like writing data to stream require interrupting the
\texttt{\class{Task}.\method{Delay}()} wait. This is achieved by calling the
\texttt{\QuicConnectionContext{}.\method{WakeUp}()} method from the \ManagedQuicConnection{}.

\subsection{Managing Packet Number Spaces}

The \ManagedQuicConnection{} class maintains an internal array of three \PacketNumberSpace{}
instances which encapsulate all relevant for state individual packet number spaces. The data
maintained in the \PacketNumberSpace{} include:

\begin{itemize}

  \item next packet number to be sent,

  \item \PacketNumberWindow{} of received packet numbers,

  \item largest received packet number and timestamp when the packet was received,

  \item \RangeSet{} of received packet numbers that are not yet acknowledged,

  \item whether an \gls{ack-eliciting-packet} was received and an \ACK{} needs to be sent,

  \item \CryptoSeal{} instances for protecting and unprotecting QUIC packets, and

  \item \SendStream{} and \ReceiveStream{} for cryptographic data from TLS to be sent in \CRYPTO{} frames.

\end{itemize}

The data in \PacketNumberSpace{}s is updated by the \ManagedQuicConnection{} each time a QUIC packet
is sent or received.

\subsection{Packet Loss Detection, Recovery and Congestion Control}

The implementation of loss detection and recovery are delegated to \RecoveryController{} class to
allow easier testing. Each sent packet is represented by an instance of \SentPacket{} which contains
packet information relevant to loss detection and recovery, such as packet number, timestamp when
the packet was sent, acked packet number ranges, packet size, and list of data ranges sent in
\STREAM{} frames.

Similarly to \PacketNumberSpace{} class used to maintain connection-wide state for each packet
number space, the \RecoveryController{} maintains an array of
\texttt{\RecoveryController{}.\PacketNumberSpace{}} instances which contain about each packet number
space that are relevant only for recovery purposes. These include:

\begin{itemize}

  \item largest packet number acknowledged by the peer,

  \item timestap of last \gls{ack-eliciting-packet} sent,

  \item \SentPacket{}s awaiting acknowlegement,

  \item \SentPacket{}s that are newly acknowledged, and

  \item \SentPacket{}s that are newly considered lost,

\end{itemize}

Additionally, the \RecoveryController{} maintains some data that is shared across all packet number
spaces. These are mostly data relevant for congestion control algorithm and
\textit{\gls{packet-pacing}}. Packet-pacing is a mechanism that evens out outgoing packets to
prevent \textit{\gls{micro-bursting}} --- a phenomenon in which packets arrive in short rapid bursts which may
overflow the receiver and cause packet loss. The data managed by \RecoveryController{}
itself include:

\begin{itemize}

  \item estimates of the current round trip time,

  \item timestamp of the next packet loss event,

  \item timestamp when the last UDP datagram was sent,

  \item number of bytes currently in-flight,

  \item current size of the congestion window, and

  \item \ICongestionController{} instance implementing the selected algorithm for congestion control.

\end{itemize}

The main interface methods exposed to the \ManagedQuicConnection{} implementation are:

\begin{description}

      \ditemproperty[\keyword]{long}{LossRecoveryTimer}{\propget}
        Timestamp when the next packet loss will occur unless an \ACK{} from peer is received.

      \ditemmethod[\keyword]{void}{OnLossDetectionTimeout}{}
        Performs loss detection and populates collections of \SentPacket{} instances on appropriate \PacketNumberSpace{} instance with packets which are now considered lost.

      \ditemmethod[\keyword]{void}{OnPacketSent}{\enum{PacketSpace}, \SentPacket{}}
        Registers the \SentPacket{} instance as sent and tracks it in loss detection algorithm.

      \ditemmethod[\keyword]{void}{OnAckReceived}{\enum{PacketSpace}, \RangeSet{}}
        Acknowledges packet numbers from provided \RangeSet{} and moves appropriate \SentPacket{} instances the collection of newly acknowledged packets.

      \ditemmethod[\keyword]{int}{GetSendingAllowance}{\Long}
        Gets the maximum size of a UDP datagram that the pacer will allow to be sent at the given timestamp.

      \ditemmethod[\keyword]{long}{GetPacingTimerForNextFullPacket}{}
        Gets timestamp when the pacer will allow sending next QUIC packet of maximum size\footnote{The maximum size of an outgoing QUIC packet depends on multiple factors. It must be small enough in order to not cause fragmentation of the UDP datagram by lower network layers. An upper limit on the UDP datagram size can be also set during handshake by the peer using an appropriate transport parameter.}.

\end{description}

\subsection{QUIC Stream Management}

The management of QUIC streams is delegated to \StreamCollection{} class. The \StreamCollection{}
tracks already created streams by their type and checks that maximum number of created streams is
not exceeded by either endpoint. It also implements efficient lookup of \ManagedQuicStream{}
instances by their Stream ID and tracks queues of streams which have QUIC frames to be sent in the
following QUIC packets.

The \StreamCollection{} class maintains two independent queues of \ManagedQuicStream{} instances:

\begin{itemize}

  \litem{Flushable} Streams that have data to send that is within the flow control limits on that stream.

  \litem{Updateable} Streams for which some other than \STREAM{} frame needs to be sent, this includes updating flow control limits or aborting the stream.

\end{itemize}

The reasoning for separate queue for flushable streams is that when composing a packet, \STREAM{}
frames are the last frames written into the QUIC packet and fill all remaining space in the
datagram. Processing the updateable queue first ensures that updates for all updateable streams are
sent as soon as possible.

\subsection{Packet Encryption}

Applying and removing packet protection is delegated to \CryptoSeal{} class, as described in
\autoref{sec:03-packet-protection}. The \CryptoSeal{} class itself implements only the logic which
is independent of the specific \gls{aead} cipher used. The steps which are specific to each
\gls{aead} cipher, such as the actual in-place encryption and decryption and calculating the header
protection mask, are delegeated to an implementation of \CryptoSealAlgorithm{} abstract class. Each
supported \gls{aead} cipher has its own \CryptoSealAlgorithm{} implementation.

The interface exposed by \CryptoSeal{} to the \ManagedQuicConnection{} consists of following
methods:

\begin{description}

    \ditemmethod[\keyword]{void}{ProtectPacket}{\SpanOf{\byte{}} packet, \Int{} pnOffset, \Long{} pn}
        Applies packet payload protection and writes \gls{aead} integrity tag at the end of the packet.

    \ditemmethod[\keyword]{void}{ProtectHeader}{\SpanOf{\byte{}} packet, \Int{} pnOffset}
        Applies header protection.

    \ditemmethod[\keyword]{void}{UnprotectHeader}{\SpanOf{\byte{}} packet, \Int{} pnOffset}
        Removes header protection.

    \ditemmethod[\keyword]{bool}{UnprotectPacket}{\SpanOf{\byte{}} packet, \Int{} pnOffset, \Long{} expectedPn}
        Attempts to remove the payload protection, returns \keyword{true} on success.

\end{description}

The meaning of the method arguments has been left out for brevity but their purpose should be
evident from their usage in source code.

\subsection{Incoming QUIC Packet Processing}

The majority of the \ManagedQuicConnection{} implementation is focused on processing QUIC packets
and the QUIC frames they contain. Processing of a QUIC packet can end with three possible results,
which are represented by \ProcessPacketResult{} enum:

\begin{itemize}

  \litem[]{\texttt{Ok}} Packet processed without errors.

  \litem[]{\texttt{DropPacket}} Packet should be discarded without informing the peer.

  \litem[]{\texttt{Error}} Received packet violates the protocol. Rest of the UDP Datagram cannot be processed and the connection will be closed with an error code.

\end{itemize}

The process of receiving the UDP datagram with QUIC packets begins in the \texttt{\ManagedQuicConnection{}.\method{ReceiveData}}
method. The individual QUIC packets are processed independently one after another using following
steps:

\begin{enumerate}

  \item detect the packet type,

  \item remove packet protection,

  \item parse and validate the packet header fields,

  \item check if the packet with same packet number has already been received,

  \item register the packet for future acknowlegement, and

  \item parse and process all contained QUIC frames.

\end{enumerate}

Because the parsed QUIC frames are represented using \keyword{ref struct}s (as explained in
\autoref{sec:03-data-representation}), each frame is processed immediately after being parsed,
independently of the other QUIC frames. The code which processes individual frames is organized
into separate functions, one for each frame type for better maintainability.

\subsection{Generating Outgoing QUIC Packets}

\todo{this section onwards is new}

The logic which generates outgoing UDP datagrams starts in the
\texttt{\ManagedQuicConnection{}.\method{SendData}} method. When generating outgoing packets, the
implementation must first determine whether it has any data to send and if so, in which QUIC packet
type it should be sent. This logic is implemented in the
\texttt{\ManagedQuicConnection{}.\method{GetWriteLevel}} method. Once the packet type to be sent is
known, the generation of the actual QUIC packet consists of following steps:

\begin{enumerate}

  \item determine the maximum size of the packet that can be sent,

  \item compose the packet header,

  \item write QUIC frames into the packet payload up to the available packet size,

  \item add padding to the packet if necessary\footnote{QUIC requires valid QUIC packets to be at least 21 bytes.},

  \item apply packet protection, and

  \item add the packet to be tracked by the \RecoveryController{}.

\end{enumerate}

The order in which the QUIC frames are generated is based on the relative importance of the frames
to make sure that the important packets fit into the packet and are not unnecessarily postponed.
Most importantly, \ACK{} frames are written first to not delay acknowlegements and \STREAM{} frames
are written last to use up the remainder of the available space.

\section{TLS Integration}

The TLS handshake related logic of the \ManagedQuicConnection{} class is delegated to an
implementation of \ITls{} interface. The \ITls{} interface defines methods needed by
\ManagedQuicConnection{}. These methods include:

\begin{description}

  \ditemmethod[\keyword]{bool}{TryAdvanceHandshake}{}
        Advances the TLS handshake by calling methods on the \ManagedQuicConnection{} (listed later).

  \ditemmethod[\keyword]{void}{OnHandshakeDataReceived}{\enum{EncryptionLevel} level, \ReadOnlySpanOf{\byte{}} data}
    Provides the TLS implementation with data received from the peer via \CRYPTO{} frames.

  \ditemmethod[\enum]{TlsCipherSuite}{GetNegotiatedCipher}{}
        Gets the identifier of the \gls{aead} cipher that was negotiated during the handshake.

  \ditemmethod{TransportParameters}{GetPeerTransportParameters}{}
        Returns \TransportParameters{} containing the transport parameters set by the peer for this connection.

  \ditemproperty[\keyword]{bool}{IsHandshakeComplete}{\propget}
        Returns true if the TLS handshake is considered complete.

\end{description}

Implementations of \ITls{} are expected to maintain a reference to the \ManagedQuicConnection{} and
call following functions when appropriate:

\begin{description}

  \ditemmethod[\keyword]{void}{SetEncryptionSecrets}{\enum{EncryptionLevel} level, \ReadOnlySpanOf{\byte{}} read, \\ \indent{} \ReadOnlySpanOf{\byte{}} write} Provides the \ManagedQuicConnection{} with read
and write secrets negotiated for the given encryption level. The encryption level refers to one of
the four encrypted QUIC packet: \texttt{Initial}, \texttt{Handshake}, \texttt{Application} (1-RTT)
and \texttt{EarlyData} (0-RTT).

  \ditemmethod[\keyword]{void}{AddHandshakeData}{\enum{EncryptionLevel} level, \ReadOnlySpanOf{\byte{}} data}
Adds TLS handshake data to be sent to the peer via \CRYPTO{} frames. The encryption level specifies
which QUIC packet should be used to send the \CRYPTO{} frame. This method can be called multiple
times.

  \ditemmethod[\keyword]{void}{FlushHandshakeData}{} Called after \method{AddHandshakeData} to
inform \ManagedQuicConnection{} that the handshake data should be sent.

  \ditemmethod[\keyword]{void}{SendTlsAlert}{\enum{EncryptionLevel} level, \Int{} alertCode} When TLS implementation
encounters an error, this function is used to provide the TLS alert code which is then used to
construct \CONNECTIONCLOSE{} frame for terminating the connection.

\end{description}

There are two \ITls{} interface implementations:

\begin{itemize}

  \litem[]{\OpenSslTls{}} Backed by modified \libopenssl{} with QUIC enabling API maintained by
Akamai~\cite{AkamaiOpensslGithub}. This implementation can be used to interoperate with other QUIC implementation and is used with \texttt{\QuicImplementationProviders{}\allowbreak{}.Managed} provider.

  \litem[]{\MockTls{}} Intended to be used when runing functional tests in continuous integration environment where the modified \libopenssl{} library is not available. This implementation cannot be used to interoperate with other QUIC implementations. \MockTls{} is used with \texttt{\QuicImplementationProviders{}\allowbreak{}.ManagedMockTls}.

\end{itemize}

The integration with TLS uses \gls{abstract-factory} to create new instances of \ITls{} when needed.
The \ManagedQuicImplementationProvider{} instance keeps a reference to \QuicTlsProvider{} which is
used to create new \ITls{} instances for \ManagedQuicConnection{}s. The concrete factory classes are
realized by \OpenSslQuicTlsProvider{} and \MockQuicTlsProvider{} classes.

Following subsections describe the two \ITls{} implementations in greater detail.

\subsection{OpenSslTls Implementation}

The \OpenSslTls{} class is a managed wrapper around the \SSL{} class from \libopenssl{} library
written in C. As per the established practice in the \dotnet{} runtime repository the managed QUIC
implementation separates the definitions of the \keyword{extern} methods from the \libopenssl{}
library into a separate \class{Interop.OpenSslQuic} class. The interop code also uses \csharp{}
function pointers, a new feature available since \dotnet{}~5. More information about \csharp{}
function pointers and other native code interop improvements done in \dotnet{}~5 can be found on
Microsoft dev blog~\cite{dotnet5interopimprovements}.

The primary objects used from the \libopenssl{} library are the \SSLCTX{} class which is a top level
object maintaining global SSL/TLS configuration, and \SSL{} class which represents one SSL/TLS
session. The \OpenSslTls{} implementation uses one global \SSLCTX{} object, and one \SSL{}
object for each \OpenSslTls{} instance.

The main part of the QUIC-enabling API exposed by the \libopenssl{} library consists of
\method{SSL_set_quic_method} function which registers callbacks from the TLS handshake state
machine. \autoref{lst:05-c-quic-method} lists the definition of the \libopenssl{} QUIC callback
functions.

\begin{myListingC}{lst:05-c-quic-method}{Callback definitions in OpenSSL library}{ssl_quic_method_st,SSL_QUIC_METHOD,SSL,SSL_CTX,uint8_t,size_t}{OSSL_ENCRYPTION_LEVEL}
struct ssl_quic_method_st {
    int (*set_encryption_secrets)(SSL *ssl, OSSL_ENCRYPTION_LEVEL level,
                                  const uint8_t *read_secret,
                                  const uint8_t *write_secret,
                                  size_t secret_len);
    int (*add_handshake_data)(SSL *ssl, OSSL_ENCRYPTION_LEVEL level,
                              const uint8_t *data, size_t len);
    int (*flush_flight)(SSL *ssl);
    int (*send_alert)(SSL *ssl, enum OSSL_ENCRYPTION_LEVEL level,
                      uint8_t alert);
};
typedef struct ssl_quic_method_st SSL_QUIC_METHOD;

int |SSL_CTX_set_quic_method|(SSL_CTX *ctx, const SSL_QUIC_METHOD *quic_method);
\end{myListingC}

\autoref{lst:05-csharp-quic-method} lists the definition of the \class{QuicMethodCallbacks} defined
by the interop layer of the managed QUIC implementation which mirrors the \class{ssl_quic_method_st}
on the managed \dotnet{} side. The \class{QuicMethodCallbacks} class uses the \csharp{} function
pointers to represent unmanaged pointers to \csharp{} functions.

\begin{myListingCsharp}{lst:05-csharp-quic-method}{[\csharp{} mirror of the \class{ssl_quic_method_st} C struct]\csharp{} mirror of the \class{ssl_quic_method_st} C struct. The comments above the fields list C-like definition of the function pointer type.}{DllImport,IntPtr, UIntPtr, StructLayout, QuicMethodCallbacks,Libraries}{OpenSslEncryptionLevel,LayoutKind}
[DllImport(Libraries.Ssl, EntryPoint = "SSL_set_quic_method")]
internal static extern unsafe int |SslSetQuicMethod|(IntPtr ssl,
    QuicMethodCallbacks* methods);

[StructLayout(LayoutKind.Sequential)]
internal unsafe struct QuicMethodCallbacks
{
    //int (*)(IntPtr ssl, OpenSslEncryptionLevel level, byte* readSecret,
    //        byte* writeSecret, UIntPtr secretLen)
    internal delegate* unmanaged[Cdecl]<IntPtr, OpenSslEncryptionLevel,
        byte*, byte*, UIntPtr, int> SetEncryptionSecrets;

    //int (*)(IntPtr ssl, OpenSslEncryptionLevel level, byte* data,
    //        UIntPtr len)
    internal delegate* unmanaged[Cdecl]<IntPtr, OpenSslEncryptionLevel,
        byte*, UIntPtr, int> AddHandshakeData;

    //int (*)(IntPtr ssl)
    internal delegate* unmanaged[Cdecl]<IntPtr, int> FlushFlight;

    //int (*)(IntPtr ssl, OpenSslEncryptionLevel level, byte alert)
    internal delegate* unmanaged[Cdecl]<IntPtr, OpenSslEncryptionLevel, byte,
        int> SendAlert;
}
\end{myListingCsharp}

The pointer to \class{QuicMethodCallbacks} structure passed to the \method{SSL_set_quic_method}
function must be valid throughout the lifetime of the \SSLCTX{} object. Therefore, the \OpenSslTls{}
class allocates the \class{QuicMethodCallbacks} instance into an unmanaged memory region using the
\texttt{\class{Marshal}.\method{AllocHGlobal}()} method and stores the resulting pointer in a
\keyword{private static} field.

In order to be able to create unmanaged function pointers to \csharp{} methods the actual methods
must be annotated using the \class{UnmanagedCallersOnlyAttribute} specifying that the caller will
use the \texttt{cdecl} calling convention.

The last piece of the \libopenssl{} callback integration is calling apropriate methods on the
\ManagedQuicConnection{} class from the callbacks. Because the callbacks are converted to unmanaged
function pointers, they must be \keyword{static} methods. Their implementation must, therefore,
translate the \texttt{\SSL{}*} pointer to the original \OpenSslTls{} instance. This is done by
allocating a \class{GCHandle} for the \OpenSslTls{} instance and storing the unmanaged pointer to
the handle as user data inside the \SSL{} instance.

\autoref{fig:05-openssl-callback} illustrates the process of calling the \method{AddHandshakeData}
callback as an example. The \ManagedQuicConnection{} instance tries to advance the TLS handshake by
calling \method{TryAdvanceHandshake} which in turn calls the \method{SSL_do_handshake} native method
in the \libopenssl{} library. This invokes the next step in the internal state automaton and as a
result, the \libopenssl{} calls the static \texttt{\OpenSslTls{}.\method{AddHandshakeData}} method
which was registered as the \texttt{add_handshake_data} callback. This function retrieves the
\class{GCHandle} from the \SSL{} instance passed in the callback and invokes the
\method{AddHandshakeData} method on the original \ManagedQuicConnection{} instance.

\begin{myFigure}{fig:05-openssl-callback}{Callback integration with \libopenssl{} library}

  \resizebox{\linewidth}{!}{\input{img/05-openssl-callback.pdf_tex}}

\end{myFigure}

\subsection{MockTls Implementation}

The \MockTls{} implementation used for running tests without dependency on the \libopenssl{} library
and is not intended for production usage. The implementation imitates the \OpenSslTls{} behavior by
simulting a successful TLS handshake and exchanging randomly generated secrets.

\section{ManagedQuicListener Implementation}

The \ManagedQuicListener{} class is only a simple wrapper around the \QuicServerSocketContext{}
instance and a \ChannelOf{\ManagedQuicConnection{}} of newly accepted connections. The
\QuicServerSocketContext{} implementation observes changes in the
\texttt{\ManagedQuicConnection{}.ConnectionState} property and inserts the newly established
connections in the \class{Channel}. The application then retrieves these connections using the
\texttt{\ManagedQuicListener{}.\method{AcceptConnectionAsync()}} method.

When the \ManagedQuicListener{} is closed, it is necessary to keep the currently established
connections alive. Disposing the \ManagedQuicListener{}, therefore, means only that the
\QuicServerSocketContext{} instance will not accept new connections. The \QuicServerSocketContext{}
class tracks active connections and is disposed when the last \ManagedQuicConnection{} is
closed.

\section{ManagedQuicStream Implementation}

As described in \autoref{sec:03-stream-implementation}, the behavior of sending and receiving parts
of the stream is implemented by \ReceiveStream{} and \SendStream{} classes. The \ManagedQuicStream{}
class itself performs only argument checking on the public API and informs the
\ManagedQuicConnection{} about the amount of data read/written in order to update flow control
limits.

\subsection{ReceiveStream Implementation}

Buffering and control flow considerations for the \ReceiveStream{} class have been analyzed in
detail in \autoref{sec:03-receive-stream}. The \ReceiveStream{} class exposes following interface to
be used by the \ManagedQuicStream{} class from the application thread:

\begin{description}

  \ditemproperty[\texttt]{\Long{}?}{Error}{\propget}
  If the stream was aborted by the sender, contains the application-level error code to be
  communicated to the application.

  \ditemmethod[\keyword]{void}{RequestAbort}{\Long{} errorCode}
  Requests that the stream is aborted by the sender. Results in sending a \STOPSENDING{} frame with
  specified application-level error code.

  \ditemmethod[\keyword]{int}{Deliver}{\SpanOf{\byte{}} destination}
  Copies the stream data into the provided \SpanOf{\byte{}}. Blocks until data are available.

  \ditemmethod[]{\ValueTaskOf{\Int{}}}{DeliverAsync}{\MemoryOf{\byte{}} destination, \CancellationToken{}}
  Asynchronous version of the \method{Deliver} method.

\end{description}

From the internal background processing thread, the main methods called from the
\ManagedQuicConnection{} are:

\begin{description}

  \ditemmethod[\keyword]{void}{OnResetStream}{\Long{} errorCode}
    Called when \RESETSTREAM{} frame for this stream was received.

  \ditemmethod[\keyword]{void}{Receive}{\Long{} offset, \ReadOnlySpanOf{\byte{}} data, \bool{} fin}
    Called when \STREAM{} frame has been received.

\end{description}

\subsection{SendStream Implementation}

Buffering and control flow considerations for the \SendStream{} class have been analyzed in detail
in \autoref{sec:03-send-stream}. The \SendStream{} class exposes following interface to be used by
the \ManagedQuicStream{} class from the application thread:

\begin{description}

  \ditemmethod[\keyword]{int}{Enqueue}{\ReadOnlySpanOf{\byte{}} data}
    Adds the provided range of data into the stream. If the
internal buffering capacity is full, this method blocks until the data can be buffered.

  \ditemmethod[]{\ValueTaskOf{\Int}}{EnqueueAsync}{\ReadOnlyMemoryOf{\byte{}} data}
    Asynchronous version of the \method{Enqueue} method.

  \ditemmethod[\keyword]{void}{MarkEndOfData}{}
    Marks the stream as finished, no more data can be written after calling this function. The
    \texttt{FIN} bit will be set in the appropriate \STREAM{} frame.

  \ditemmethod[\keyword]{void}{RequestAbort}{\Long{} errorCode}
    Requests that the stream be aborted with specified errorCode. This method is also called when
    \STOPSENDING{} frame was received for this stream.

\end{description}

From the internal background processing thread, the main methods called from the
\ManagedQuicConnection{} are:

\begin{description}

    \ditemmethod[\texttt]{(\Long{} offset, \Long{} count)}{GetNextSendableRange}{}
        Returns the next consecutive range of data that is in \textit{pending} state. The next data
to be sent in STREAM{} frame will be from this range.

    \ditemmethod[\keyword]{void}{CheckOut}{\SpanOf{\byte} destination}
        Copies the data from the range returned from \method{GetNextSendableRange} into the
destination buffer. The copied data is transitoned into \textit{in-flight} state.

    \ditemmethod[\keyword]{void}{OnLost}{\Long{} offset, \Long{} count}
        Marks the range of data as lost, transitioning them back to \textit{pending} state.

    \ditemmethod[\keyword]{void}{OnAck}{\Long{} offset, \Long{} count, \bool{} fin}
        Marks the range of data as \textit{acknowleged}. Allowing the underlying buffers to be reused.

\end{description}

\section{Tests Implementation}

The QUIC implementation is covered by an extensive suite of unit tests and functional tests. The
unit tests focus on the correctness of the individual parts of the managed QUIC implementation, and
that the QUIC packets sent by the implementation conform to the QUIC protocol specification.
Functional tests, on the other hand, tests high-level functionality like being able to send and
receive data, and that the public API behavior conforms to the public API specification.

\subsection{Unit Tests}

\subsection{Functional Tests}

The \filename{System.Net.Quic} project contains a large suite functional tests against the public
QUIC API. The tests are structured in a way that allows them to run against all QUIC implementation
providers in the library. Also, the \QuicStream{} class is tested using \textit{stream conformance
  tests} --- a suite of tests run for each implementation of the \Stream{} class to ensure consistent
behavior of all implementations.

In order to allow running tests against different implementation providers, the test methods are
defined in \QuicListenerTests{}, \QuicConnectionTests{} and \QuicStreamTests{} generic classes,
which share a common base class \QuicTestBase{}. The type argument for all four of these classes is
constrained to be an implementation of \interface{IQuicImplProviderFactory} interface which allows
creating \QuicListener{} and \QuicConnection{} instances with desired implementation provider.

The \xUnit{} framework does not run tests from generic classes by itself. Instead, the generic test
suite must be ``instantiated'' by declaring a non-generic class deriving from the generic type. For
example, \class{QuicStreamTests_Managed\allowbreak{}Provider} derives from the
\genericClass{QuicStreamTests}{\class{ManagedProvider\allowbreak{}Factory}} class which makes
\xUnit{} run the tests from \QuicStreamTests{} class against the
\texttt{\QuicImplementationProviders{}.Managed} provider. These specific test classes are also
annotated by \class{ConditionalClassAttribute} which instructs \xUnit{} to run the tests only if the
given provider is supported in the current environment.

Similar mechanism is used to run stream conformance tests against all QUIC implementation providers.
