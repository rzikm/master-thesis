\chapter{Developer Documentation}

The Managed QUIC implementation developed in this thesis is contained in a fork of the official
\dotnet{} runtime repository. The source code of this fork is attached in \todo{path to the src in
  attachments.}.

The documentation inside the \dotnet{} runtime repository contains detailed workflow instructions
necessary for \dotnet{} runtime development. These instructions explain the necessary
prerequisities, how to build the product and run tests. The top-level file of the workflow
instructions is located at \filename{docs/workflow/README.md}.

This chapter will focus on the \filename{System.Net.Quic} library which contains the QUIC protocol
implementation. The source code for this library is located inside the
\filename{src/dotnet-runtime/src/libraries/System.Net.Quic/} directory of the \dotnet{} runtime
codebase. The directory listing in \autoref{lst:05-system-net-quic-structure} shows the structure of
the \filename{System.Net.Quic} project directory. The listing also emphasises the \filename{Managed}
and \filename{UnitTests} directories which contain the code developed as part of this thesis. These
directories are the main focus of this chapter.

\newcommand{\mydtcomment}[1]{\DTcomment{#1}}
% use smaller width to make the tree more compact
\DTsetlength{0.2em}{0.6em}{0.2em}{0.4pt}{1.6pt}
\renewcommand{\DTstylecomment}[1]{{\footnotesize\rmfamily #1}}
\renewcommand{\DTstyle}[1]{{\footnotesize\texttt{#1}}}
\definecolor{dtemphcolor}{rgb}{0,0,0.75}
\newcommand{\dtemph}[1]{\textcolor{dtemphcolor}{\emph{#1}}}

\begin{myListing}[Directory structure of the System.Net.Quic project.]{lst:05-system-net-quic-structure}{Directory structure of the System.Net.Quic project. Emphasised items contain the implementation developed in this thesis.}
\dirtree{%
  .1 {src/dotnet-runtime/src/libraries/System.Net.Quic/}.
  .2 {ref}\mydtcomment{Refererence assembly code}.
  .2 {src}\mydtcomment{Main library source code}.
  .3 {Resources}.
  .4 {Strings.resx}\mydtcomment{Definition of localizable strings like exception messages.}.
  .3 {System}.
  .4 {Net}.
  .5 {Quic}.
  .6 {Implementations}\mydtcomment{Root directory for all QUIC implementations}.
  .7 {\dtemph{Managed}}\mydtcomment{\dtemph{This thesis' implementation sources}}.
  .7 {MsQuic}\mydtcomment{\libmsquic{}-based implementation sources}.
  .7 {Mock}\mydtcomment{Mock implementation used only in tests}.
  .6 {Interop}\mydtcomment{Imports from native libraries}.
  .3 {System.Net.Quic.csproj}.
  .2 {tests}\mydtcomment{Library tests source code}.
  .3 {certs}\mydtcomment{X.509 certificates used in tests}.
  .4 {cert.crt}\mydtcomment{Public certificate file}.
  .4 {cert.key}\mydtcomment{Private key file}.
  .3 {FunctionalTests}\mydtcomment{Tests against the public API}.
  .4 {System.Net.Quic.Functional.Tests.csproj}.
  .3 {\dtemph{UnitTests}}\mydtcomment{\dtemph{Managed implementation unit tests}}.
  .4 {\dtemph{System.Net.Quic.Unit.Tests.csproj}}.
  .2 {Directory.Build.props}.
  .2 {System.Net.Quic.sln}.
}
\end{myListing}

\section{QUIC Implementation Providers}

The \filename{System.Net.Quic} project internally contains an infrastructure for switching between
multiple implementations of the QUIC protocol. The API classes themselves are \keyword{sealed} but
they delegate all methods to polymorphic \textit{implementation providers}. Each \QuicListener{},
\QuicConnection{}, and \QuicStream{} instance contains a reference to a \QuicListenerProvider{},
\QuicConnectionProvider{}, or \QuicStreamProvider{} instance, respectively. Implementations of each
provider are provided by each QUIC implementation in the \filename{System.Net.Quic} library. Figure
\autoref{fig:05-quic-impl-providers} illustrates this indirection layer using a class diagram.

\begin{myFigure}{fig:05-quic-impl-providers}{Implementation providers for the QUIC API classes}

\resizebox{0.95\linewidth}{!}{\input{img/05-quic-implementation-providers.pdf_tex}}

\end{myFigure}

Creation of new \QuicListener{} and \QuicConnection{} instances is implemented using the
\gls{abstract-factory}~\cite{wiki:abstract-factory-pattern}. There are multiple implementations of
\QuicImplementationProvider{} class, one for each QUIC implementation. Instances of
\QuicImplementationProvider{} class are available as static properties of the
\class{QuicImplementationProviders} static class.

There were two pre-existing providers in the \filename{System.Net.Quic} project. Implementation of
these two providers is not the primary focus of this text and, therefore, this text will not provide
further details on these providers:

\begin{itemize}

  \litem[]{\texttt{MsQuic}} QUIC implementation backed by \libmsquic{} native library

  \litem[]{\texttt{Mock}} A mock QUIC implementation for use in tests

\end{itemize}

This thesis provides following two new provideres:

\begin{itemize}

  \litem[]{\texttt{Managed}} Managed implementation with TLS backed by \libopenssl{} fork with QUIC enabling API.

  \litem[]{\texttt{ManagedMockTls}} Managed implementation with mock TLS implementation, which does not depend on external libraries, but cannot interoperate with other QUIC implementations.

\end{itemize}

Additionally, there is the \texttt{Default} provider which in our implementation redirects to
\texttt{Managed}, but can be redirected to other implementations by setting
\texttt{DOTNETQUIC_PROVIDER} environment variable to the desired provider name.

The \QuicListener{} and \QuicConnection{} classes have a constructor overload which accepts an
instance of the \QuicImplementationProvider{} to be used. This way, the QUIC implementation can be
selected during runtime. This also allows reusing a suite of functional tests for all
implementations by simply changing the implementation provider.

\section{Managed QUIC Implementation Overview}

The source code for the managed implementation developed in this thesis is located under the
\filename{System.Net.Quic/src/System/Net/Quic/Implementations/Managed/} subdirectory.
\autoref{lst:05-managed-quic-structure} outlines the directory structure of the implementation.

\begin{myListing}{lst:05-managed-quic-structure}{Directory structure of the managed QUIC implementation}
\dirtree{%
  .1 {System.Net.Quic/src/System/Net/Quic/Implementations/Managed}.
  .2 {Internal}\mydtcomment{Internal code of the implementation}.
  .3 {Crypto}\mydtcomment{Cryptographic facilities}.
  .3 {Frames}\mydtcomment{Definition of QUIC frames}.
  .3 {Headers}\mydtcomment{Definition of QUIC packet headers}.
  .3 {Packets}\mydtcomment{QUIC packet number spaces handling}.
  .3 {Parsing}\mydtcomment{Parsing of QUIC primitives}.
  .3 {Recovery}\mydtcomment{Loss detection and recovery}.
  .3 {Sockets}\mydtcomment{Servicing socket IO}.
  .3 {Streams}\mydtcomment{Stream buffering}.
  .3 {Tls}\mydtcomment{TLS integration}.
  .4 {Mock}\mydtcomment{Mock TLS implementation}.
  .4 {OpenSsl}\mydtcomment{OpenSSL TLS integration}.
  .3 {Tracing}\mydtcomment{Tracing and logging facilities}.
  .2 {ManagedQuicConnection.cs}\mydtcomment{Implementation of public API}.
  .2 {ManagedQuicConnection.Frames.cs}\mydtcomment{Processing of QUIC frames}.
  .2 {ManagedQuicConnection.Packets.cs}\mydtcomment{Processing of QUIC packets}.
  .2 {ManagedQuicConnection.Recovery.cs}\mydtcomment{Handling packet loss}.
  .2 {ManagedQuicConnection.Stream.cs}\mydtcomment{Stream management}.
  .2 {ManagedQuicImplementationProvider.cs}\mydtcomment{Abstract factory implementation}.
  .2 {ManagedQuicListener.cs}\mydtcomment{Implementation of public API}.
  .2 {ManagedQuicStream.cs}\mydtcomment{Implementation of public API}.
}
\end{myListing}

The implementation is exposed using the \ManagedQuicListener{}, \ManagedQuicConnection{},
\ManagedQuicStream{} implementation provider classes and the \ManagedQuicImplementationProvider{}
factory. The source code for these classes can be found in the root directory of the implementation.

The high-level architecture has been described in \autoref{sec:03-high-level-architecture}. This and
following sections will provide further implementation details. The class diagram in
\autoref{fig:05-high-level-class-diagram} shows the releationship between the key architecture
classes which were also mentioned in \autoref{fig:03-architecture} and
\autoref{fig:03-socket-context-architecture}. These classes are:

\begin{itemize}

  \litem[]{\ManagedQuicConnection{}} Implementation provider for \QuicConnection{}. Implements stateful connection logic.

  \litem[]{\ManagedQuicListener{}} Implementation provider for \QuicListener{}. Maintains a queue of incomming connections to be accepted by the application.

  \litem[]{\QuicConnectionContext{}} Class hosting the background thread for servicing a single \ManagedQuicConnection{}, including timeout expiration and sending or receiving UDP datagrams with QUIC packets.

  \litem[]{\QuicSocketContext{}} Abstract class handling basic sending and receiving of UDP datagrams, base class for \QuicClientSocketContext{} and \QuicServerSocketContext{}.

  \litem[]{\QuicServerSocketContext{}} Implements server-side stateless UDP datagram processing and dispatch of incoming UDP datagrams to appropriate \QuicConnectionContext{} instance.

  \litem[]{\QuicClientSocketContext{}} Implements client-side \QuicSocketContext{} behavior, passing all packets to a single single \QuicConnectionContext{}.

\end{itemize}

\begin{myFigure}{fig:05-high-level-class-diagram}{Relationship between key classes of managed QUIC implementation}

\resizebox{0.80\linewidth}{!}{\input{img/05-high-level-class-diagram.pdf_tex}}

\end{myFigure}

\section{Supporting Data Structures}

The QUIC implementation requires a few specialized data structures for internal implementation.

\todo{should this be in analysis or documentation?}

\subsection{RangeSet}

Efficient representation of acknowledged ranges of packet numbers and maintaining information about
which parts of the QUIC stream have been sent or acknowledged require a data structure capable of
efficiently performing set operations on ranges of integers. The \RangeSet{} class represents such a
set.

It is expected that the number of ranges in one \RangeSet{} instance will be rather small. Therefore
our implementation uses a sorted \ListOf{\class{T}} instance to store individual ranges. The ranges
themselves are represented by \class{RangeSet.\allowbreak{}Range} struct which contains the first and last
element represented by the range.

\subsection{PacketNumberWindow}

The \PacketNumberWindow{} class is used to test if QUIC packet the given packet number has already
been received. Internally, it contains two 64-bit fields: a bitmask marking the received bits and an
integer representing the packet number represented by the least significant bit of the mask. Marking
a packet number as received consists of setting a particular bit in the mask, shifting the other
bits if necessary. \todo{is this clear or does it need an illustration? YES, illustration!}

The data structure can maintain state only for 64 consecutive packet numbers. This leads to packets
with packet number under the window being defensively marked as already received and, therefore,
discarded. The tollerance of the loss detection algorithm outlined in
\autoref{sec:02-loss-detection} allow way smaller packet reordering. In fact, the specification
suggests maximum reordering tollerance of 3, meaning that receiving a packet number should mark all
packets as lost except the previous two. Therefore, it is very likely that any newly received packet
with packet number under the window maintained by the \PacketNumberWindow{} instance is already
deemed lost and its data retransmitted in a different packet. Thus the width of 64 of the packet
number window is sufficient.

\todo{possibly include segmented ArrayBuffer, if I decide to implement it myself}

\section{ManagedQuicConnection Implementation}

The \ManagedQuicConnection{} class implements the stateful QUIC connection logic which makes up most
of the managed QUIC implementation. The source code of the \ManagedQuicConnection{} class is
separated by area into multiple files, as outlined previously in
\autoref{lst:05-managed-quic-structure}:

\todo{maybe remove this list}

\begin{itemize}

  \litem{Public API} Implementation of the public API methods inherited from the \QuicConnectionProvider{} class.

  \litem{Packets} Processing individual QUIC packets, applying and removing the packet protection, generating packets to be sent.

  \litem{Frames} Processing individual QUIC frames, and generating frames for outgoing packets.

  \litem{Stream} Management of created QUIC streams and flow control limits.

  \litem{Recovery} Tracking of sent QUIC packets, handling of acknowlegements and packet loss. Congestion window management.

\end{itemize}

Following subsections describe the major parts of the implementation.

\subsection{Integration with Socket Management}

The \ManagedQuicConnection{} implementation is separated from socket IO management. Also, to allow
for deterministic unit testing, the implementation does not maintain an internal timer that would
automatically invoke some logic on expiration. Instead, all interactions with a \Socket{} are driven
externally by a \QuicConnectionContext{} class which maintains a background processing thread for
handling timeouts and sending and receiving of QUIC packets. The interface used by
\QuicConnectionContext{} consists of following members on \ManagedQuicConnection{}:

\begin{description}

  \ditemproperty[\enum]{QuicConnectionState}{ConnectionState}{\propget} The current state of the connection. Used to detect transitions to, e.g., connected state or closed state.

  \ditemmethod[\keyword]{void}{SendData}{\QuicWriter{},\keyword{out} \class{EndPoint}, \class{QuicSocketContext.SendContext}}
  Allows the connection to write a UDP datagram to be sent into the \QuicWriter{} instance and specify the \class{EndPoint} to which the UDP datagram should be sent. The \class{SendContext} instance contains additional data like the current timestamp.

  \ditemmethod[\keyword]{void}{ReceiveData}{\QuicReader{}, \class{EndPoint}, \class{QuicSocketContext.RecvContext}}
  Processes a datagram from the provided \QuicReader{} instance. The \class{Recv\allowbreak{}Context} instance contains additional data like current timestamp.

  \ditemmethod[\keyword]{long}{GetNextTimerTimestamp}{}
  Retrieves the timestamp when the next internal timer of expires. Examples of such timer are loss detection timer, draining timer before closing the connection, or pacing timer for evening out the outbound packet flow. When the timer expires, the \ManagedQuicConnection{} instance may have more data to send.

\end{description}

The value of \method{GetNextTimerTimestamp} is then used to suspend the background processing thread
in order not to consume CPU resources. The background processing thread waits until either the timer
expires using \texttt{\class{Task}.\method{Delay}()} or until a new QUIC packet arrives. However,
some application code actions like writing data to stream require interrupting the
\texttt{\class{Task}.\method{Delay}()} wait. This is achieved by calling the
\texttt{\QuicConnectionContext{}.\method{WakeUp}()} method from the \ManagedQuicConnection{}.

\subsection{Managing Packet Number Spaces}

The \ManagedQuicConnection{} class maintains an internal array of three \PacketNumberSpace{}
instances which encapsulate all relevant for state individual packet number spaces. The data
maintained in the \PacketNumberSpace{} include:

\begin{itemize}

  \item next packet number to be sent,

  \item \PacketNumberWindow{} of received packet numbers,

  \item largest received packet number and timestamp when the packet was received,

  \item \RangeSet{} of received packet numbers that are not yet acknowledged,

  \item whether an \gls{ack-eliciting-packet} was received and an \ACK{} needs to be sent,

  \item \CryptoSeal{} instances for protecting and unprotecting QUIC packets, and

  \item \SendStream{} and \ReceiveStream{} for cryptographic data from TLS to be sent in \CRYPTO{} frames.

\end{itemize}

The data in \PacketNumberSpace{}s is updated by the \ManagedQuicConnection{} each time a QUIC packet
is sent or received.

\subsection{Packet Loss Detection, Recovery and Congestion Control}

The implementation of loss detection and recovery are delegated to \RecoveryController{} class to
allow easier testing. Each sent packet is represented by an instance of \SentPacket{} which contains
packet information relevant to loss detection and recovery, such as packet number, timestamp when
the packet was sent, acked packet number ranges, packet size, and list of data ranges sent in
\STREAM{} frames.

Similarly to \PacketNumberSpace{} class used to maintain connection-wide state for each packet
number space, the \RecoveryController{} maintains an array of
\texttt{\RecoveryController{}.\PacketNumberSpace{}} instances which contain about each packet number
space that are relevant only for recovery purposes. These include:

\begin{itemize}

  \item largest packet number acknowledged by the peer,

  \item timestap of last \gls{ack-eliciting-packet} sent,

  \item \SentPacket{}s awaiting acknowlegement,

  \item \SentPacket{}s that are newly acknowledged, and

  \item \SentPacket{}s that are newly considered lost,

\end{itemize}

Additionally, the \RecoveryController{} maintains some data that is shared across all packet number
spaces. In addition to congestion window management, \RecoveryController{} also implements These are
mostly data relevant for congestion control algorithm and \textit{\gls{packet-pacing}} --- a mechanism that
evens out outgoing packets to prevent micro bursts. The data managed by \RecoveryController{} itself
include:

\begin{itemize}

  \item estimates of the current round trip time,

  \item timestamp of the next packet loss event,

  \item timestamp when the last UDP datagram was sent,

  \item number of bytes currently in-flight,

  \item current size of the congestion window, and

  \item \ICongestionController{} instance implementing the selected algorithm for congestion control.

\end{itemize}

The main interface methods exposed to the \ManagedQuicConnection{} implementation are:

\begin{description}

      \ditemproperty[\keyword]{long}{LossRecoveryTimer}{\propget}
        Timestamp when the next packet loss will occur unless an \ACK{} from peer is received.

      \ditemmethod[\keyword]{void}{OnLossDetectionTimeout}{}
        Performs loss detection and populates collections of \SentPacket{} instances on appropriate \PacketNumberSpace{} instance with packets which are now considered lost.

      \ditemmethod[\keyword]{void}{OnPacketSent}{\enum{PacketSpace},\SentPacket{}}
        Registers the \SentPacket{} instance as sent and tracks it in loss detection algorithm.

      \ditemmethod[\keyword]{void}{OnAckReceived}{\enum{PacketSpace}, \RangeSet{}}
        Acknowledges packet numbers from provided \RangeSet{} and moves appropriate \SentPacket{} instances the collection of newly acknowledged packets.

      \ditemmethod[\keyword]{int}{GetSendingAllowance}{\Long}
        Gets the maximum size of a UDP datagram that the pacer will allow to be sent at the given timestamp.

      \ditemmethod[\keyword]{long}{GetPacingTimerForNextFullPacket}{}
        Gets timestamp when the pacer will allow sending next QUIC packet of maximum size\footnote{The maximum size of an outgoing QUIC packet depends on multiple factors. It must be small enough in order to not cause fragmentation of the UDP datagram by lower network layers. An upper limit on the UDP datagram size can be also set during handshake by the peer using an appropriate transport parameter.}.

\end{description}

\subsection{QUIC Stream Management}

The management of QUIC streams is delegated to \StreamCollection{} class. The \StreamCollection{}
tracks already created streams by their type and checks that maximum number of created streams is
not exceeded by either endpoint. It also implements efficient lookup of \ManagedQuicStream{}
instances by their Stream ID and tracks queues of streams which have QUIC frames to be sent in the
following QUIC packets.

The \StreamCollection{} class maintains two independent queues of \ManagedQuicStream{} instances:

\begin{itemize}

  \litem{Flushable} Streams that have data to send that is within the flow control limits on that stream.

  \litem{Updateable} Streams for which some other than \STREAM{} frame needs to be sent, this includes updating flow control limits or aborting the stream.

\end{itemize}

The reasoning for separate queue for flushable streams is that when composing a packet, \STREAM{}
frames are the last frames written into the QUIC packet and fill all remaining space in the
datagram. Processing the updateable queue first ensures that updates for all updateable streams are
sent as soon as possible.

\subsection{Packet Encryption}

Applying and removing packet protection is delegated to \CryptoSeal{} class, as described in
\autoref{sec:03-packet-protection}. The \CryptoSeal{} class itself implements only the logic which
is independent of the specific \gls{aead} cipher used. The steps which are specific to each
\gls{aead} cipher, such as the actual in-place encryption and decryption and calculating the header
protection mask, are delegeated to an implementation of \CryptoSealAlgorithm{} abstract class. Each
supported \gls{aead} cipher has its own \CryptoSealAlgorithm{} implementation.

The interface exposed by \CryptoSeal{} to the \ManagedQuicConnection{} consists of following
methods:

\begin{description}

    \ditemmethod[\keyword]{void}{ProtectPacket}{\SpanOf{\byte{}},\Int{},\Int{},\Long{}}
        Applies packet payload protection and writes \gls{aead} integrity tag at the end of the packet.

    \ditemmethod[\keyword]{void}{ProtectHeader}{\SpanOf{\byte{}},\Int{}}
        Applies header protection.

    \ditemmethod[\keyword]{void}{UnprotectHeader}{\SpanOf{\byte{}},\Int{}}
        Removes header protection.

    \ditemmethod[\keyword]{bool}{UnprotectPacket}{\SpanOf{\byte{}},\Int{},\Int{},\Long{}}
        Attempts to remove the payload protection, returns \keyword{true} on success.

\end{description}

The meaning of the method arguments has been left out for brevity but their purpose should be
evident from their usage in source code.

\subsection{Incoming QUIC Packet Processing}

The majority of the \ManagedQuicConnection{} implementation is focused on processing QUIC packets
and the QUIC frames they contain. Processing of a QUIC packet can end with three possible results,
which are represented by \ProcessPacketResult{} enum:

\begin{itemize}

  \litem[]{\texttt{Ok}} Packet processed without errors.

  \litem[]{\texttt{DropPacket}} Packet should be discarded without informing the peer.

  \litem[]{\texttt{Error}} Received packet violates the protocol. Rest of the UDP Datagram cannot be processed and the connection will be closed with an error code.

\end{itemize}

The process of receiving the UDP datagram with QUIC packets begins in the \texttt{\ManagedQuicConnection{}.\method{ReceiveData}}
method. The individual QUIC packets are processed independently one after another using following
steps:

\begin{enumerate}

  \item detect the packet type

  \item remove packet protection

  \item parse and validate the packet header fields

  \item check if the packet with same packet number has already been received

  \item register the packet for future acknowlegement

  \item parse and process all contained QUIC frames

\end{enumerate}

Because the parsed QUIC frames are represented using \keyword{ref struct}s (as explained in
\autoref{sec:03-data-representation}), each frame is processed immediately after being parsed,
independently of the other QUIC frames. The code which processes individual frames is organized
into separate functions, one for each frame type for better maintainability.

\subsection{Generating Outgoing QUIC Packets}

The logic which generates outgoing UDP datagrams starts in the
\texttt{\ManagedQuicConnection{}.\method{SendData}} method. When generating outgoing packets, the
implementation must first determine whether it has any data to send and if so, in which QUIC packet
type it should be sent. This logic is implemented in the
\texttt{\ManagedQuicConnection{}.\method{GetWriteLevel}} method. Once the packet type to be sent is
known, the generation of the actual QUIC packet consists of following steps:

\begin{enumerate}

  \item determine the maximum size of the packet that can be sent

  \item

\end{enumerate}

\subsection{TLS Integration}

\section{ManagedQuicListener Implementation}

\section{ManagedQuicStream Implementation}

\section{Tests Implementation}

The QUIC implementation is covered by an extensive suite of unit tests and functional tests. The
unit tests focus on the correctness of the individual parts of the managed QUIC implementation, and
that the QUIC packets sent by the implementation conform to the QUIC protocol specification.
Functional tests, on the other hand, tests high-level functionality like being able to send and
receive data, and that the public API behavior conforms to the public API specification.

\subsection{Unit Tests}

\subsection{Functional Tests}
