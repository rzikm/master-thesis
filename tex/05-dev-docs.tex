\chapter{Developer Documentation}

The Managed QUIC implementation developed in this thesis is contained in the
\filename{System.Net.Quic} project in a fork of the official \dotnet{} runtime repository. The
source code is attached in \todo{path to the src in attachments.}

The source code for the \filename{System.Net.Quic} project is located inside the
\filename{src/dotnet-runtime/src/libraries/System.Net.Quic/} directory. The directory listing in
\autoref{lst:05-system-net-quic-structure} shows the structure of the project directory. The figure
also emphasises the \filename{Managed} and \filename{UnitTests} directories which contain the code
developed as part of this thesis. These directories are the main focus of this chapter.

\newcommand{\mydtcomment}[1]{\DTcomment{#1}}

% use smaller width to make the tree more compact
\DTsetlength{0.2em}{0.6em}{0.2em}{0.4pt}{1.6pt}
\renewcommand{\DTstylecomment}[1]{{\footnotesize\rmfamily #1}}
\renewcommand{\DTstyle}[1]{{\footnotesize\texttt{#1}}}
\definecolor{dtemphcolor}{rgb}{0,0,0.75}
\newcommand{\dtemph}[1]{\textcolor{dtemphcolor}{\emph{#1}}}

\begin{myListing}[Directory structure of the System.Net.Quic project.]{lst:05-system-net-quic-structure}{Directory structure of the System.Net.Quic project. Emphasised items contain the implementation developed in this thesis.}
\dirtree{%
  .1 {src/dotnet-runtime/src/libraries/System.Net.Quic/}.
  .2 {ref}\mydtcomment{Refererence assembly code}.
  .2 {src}\mydtcomment{Main library source code}.
  .3 {Resources}.
  .4 {Strings.resx}\mydtcomment{Definition of localizable strings like exception messages.}.
  .3 {System}.
  .4 {Net}.
  .5 {Quic}.
  .6 {Implementations}\mydtcomment{Root directory for all QUIC implementations}.
  .7 {\dtemph{Managed}}\mydtcomment{\dtemph{This thesis' implementation sources}}.
  .7 {MsQuic}\mydtcomment{\libmsquic{}-based implementation sources}.
  .7 {Mock}\mydtcomment{Mock implementation used only in tests}.
  .6 {Interop}\mydtcomment{Imports from native libraries}.
  .3 {System.Net.Quic.csproj}.
  .2 {tests}\mydtcomment{Library tests source code}.
  .3 {certs}\mydtcomment{X.509 certificates used in tests}.
  .4 {cert.crt}\mydtcomment{Public certificate file}.
  .4 {cert.key}\mydtcomment{Private key file}.
  .3 {FunctionalTests}\mydtcomment{Tests against the public API}.
  .4 {System.Net.Quic.Functional.Tests.csproj}.
  .3 {\dtemph{UnitTests}}\mydtcomment{\dtemph{Managed implementation unit tests}}.
  .4 {\dtemph{System.Net.Quic.Unit.Tests.csproj}}.
  .2 {Directory.Build.props}.
  .2 {System.Net.Quic.sln}.
}
\end{myListing}

\todo{sections for: development (environment setup, setup for debugging)? running tests?}

\section{QUIC Implementation Providers}

The \filename{System.Net.Quic} project contains multiple implementations of the QUIC protocol. This
is not achieved via polymorphism of the QUIC API classes, but rather using indirection to
\textit{implementation providers}. Each \QuicListener{}, \QuicConnection{}, and \QuicStream{}
instance contains a reference to a \QuicListenerProvider{}, \QuicConnectionProvider{}, or
\QuicStreamProvider{} instance, respectively. Implementations of each provider are provided by each
QUIC implementation in the \filename{System.Net.Quic} library. Figure
\autoref{fig:05-quic-impl-providers} illustrates this indirection layer using a class diagram.

\begin{myFigure}{fig:05-quic-impl-providers}{Implementation providers for the QUIC API classes}

\resizebox{0.95\linewidth}{!}{\input{img/05-quic-implementation-providers.pdf_tex}}

\end{myFigure}

Creation of new \QuicListener{} and \QuicConnection{} instances is implemented using the
\gls{abstract-factory}~\cite{wiki:abstract-factory-pattern}. There are multiple implementations of
\QuicImplementationProvider{} class, one for each QUIC implementation. Instances of
\QuicImplementationProvider{} class are available as static properties of the
\class{QuicImplementationProviders} static class. There are five such providers:

\begin{itemize}

  \litem[]{\texttt{Managed}} Managed implementation with TLS backed by \libopenssl{} fork with QUIC enabling API.

  \litem[]{\texttt{ManagedMockTls}} Managed implementation with mock TLS, which does not depend on external TLS implementation, but cannot interoperate with other QUIC implementations.

  \litem[]{\texttt{MsQuic}} QUIC implementation backed by \libmsquic{} native library.

  \litem[]{\texttt{Mock}} A mock QUIC implementation for use in tests.

  \litem[]{\texttt{Default}} The default implementation. Same as \texttt{Managed}, but can be redirected to other implementations by setting \texttt{DOTNETQUIC_PROVIDER} environment variable to the desired provider name.

\end{itemize}

The \QuicListener{} and \QuicConnection{} classes have a constructor overload which accepts an
instance of the \QuicImplementationProvider{} to be used. This way, the QUIC implementation can be
selected during runtime. This also allows reusing a suite of functional tests for all
implementations by simply changing the implementation provider.

\section{Managed QUIC Implementation}

The source code for the managed implementation developed in this thesis is located under the
\filename{System.Net.Quic/src/System/Net/Quic/Implementations/Managed/} subdirectory.
\autoref{lst:05-managed-quic-structure} outlines the directory structure of the implementation.

\begin{myListing}{lst:05-managed-quic-structure}{Directory structure of the managed QUIC implementation}
\dirtree{%
  .1 {System.Net.Quic/src/System/Net/Quic/Implementations/Managed}.
  .2 {Internal}\mydtcomment{Internal code of the implementation}.
  .3 {Crypto}\mydtcomment{Cryptographic facilities}.
  .3 {Frames}\mydtcomment{Definition of QUIC frames}.
  .3 {Headers}\mydtcomment{Definition of QUIC packet headers}.
  .3 {Packets}\mydtcomment{QUIC packet number spaces handling}.
  .3 {Parsing}\mydtcomment{Parsing of QUIC primitives}.
  .3 {Recovery}\mydtcomment{Loss detection and recovery}.
  .3 {Sockets}\mydtcomment{Servicing socket IO}.
  .3 {Streams}\mydtcomment{Stream buffering}.
  .3 {Tls}\mydtcomment{TLS integration}.
  .4 {Mock}\mydtcomment{Mock TLS implementation}.
  .4 {OpenSsl}\mydtcomment{OpenSSL TLS integration}.
  .3 {Tracing}\mydtcomment{Tracing and logging facilities}.
  .2 {ManagedQuicConnection.cs}\mydtcomment{Implementation of public API}.
  .2 {ManagedQuicConnection.Frames.cs}\mydtcomment{Processing of QUIC frames}.
  .2 {ManagedQuicConnection.Packets.cs}\mydtcomment{Processing of QUIC packets}.
  .2 {ManagedQuicConnection.Recovery.cs}\mydtcomment{Handling packet loss}.
  .2 {ManagedQuicConnection.Stream.cs}\mydtcomment{Stream management}.
  .2 {ManagedQuicImplementationProvider.cs}\mydtcomment{Abstract factory}.
  .2 {ManagedQuicListener.cs}\mydtcomment{Implementation of public API}.
  .2 {ManagedQuicStream.cs}\mydtcomment{Implementation of public API}.
}
\end{myListing}

The implementation is exposed using the \ManagedQuicListener{}, \ManagedQuicConnection{},
\ManagedQuicStream{} implementation provider classes and the \ManagedQuicImplementationProvider{}
factory. The source code for these classes can be found in the root directory of the implementation.

\subsection{Implementation Overview}

The high-level architecture has been described in \autoref{sec:03-high-level-architecture}. This and
following sections will provide further implementation details. The class diagram in
\autoref{fig:05-high-level-class-diagram} shows the releationship between the key architecture
classes which were also mentioned in \autoref{fig:03-architecture} and
\autoref{fig:03-socket-context-architecture}. These classes are:

\begin{itemize}

  \litem[]{\ManagedQuicConnection{}} Implementation provider for \QuicConnection{}. Implements stateful connection logic.

  \litem[]{\ManagedQuicListener{}} Implementation provider for \QuicListener{}. Maintains a queue of incomming connections to be accepted by the application.

  \litem[]{\QuicConnectionContext{}} Class hosting the background thread for servicing a single \ManagedQuicConnection{}, including timeout expiration and sending or receiving UDP datagrams with QUIC packets.

  \litem[]{\QuicSocketContext{}} Abstract class handling basic sending and receiving of UDP datagrams, base class for \QuicClientSocketContext{} and \QuicServerSocketContext{}.

  \litem[]{\QuicServerSocketContext{}} Implements server-side stateless UDP datagram processing and dispatch of incoming UDP datagrams to appropriate \QuicConnectionContext{} instance.

  \litem[]{\QuicClientSocketContext{}} Implements client-side \QuicSocketContext{} behavior, passing all packets to a single single \QuicConnectionContext{}.

\end{itemize}

\begin{myFigure}{fig:05-high-level-class-diagram}{Relationship between key classes of managed QUIC implementation}

\resizebox{0.87\linewidth}{!}{\input{img/05-high-level-class-diagram.pdf_tex}}

\end{myFigure}

\subsection{Matching QUIC Packets to Connections}



\subsection{ManagedQuicConnection}

\subsection{Supporting Data Structures}

The QUIC implementation requires a few specialized data structures.

\todo{should this be in analysis or documentation?}

\subsubsection{RangeSet}

Efficient representation of acknowledged ranges of packet numbers and maintaining information about
which parts of the QUIC stream have been sent or acknowledged require a data structure capable of
efficiently performing set operations on ranges of integers. The \RangeSet{} class represents such a
set.

It is expected that the number of ranges in one \RangeSet{} instance will be rather small. Therefore
our implementation uses a sorted \class{List<T>} instance to store individual ranges. The ranges
themselves are represented by \class{RangeSet.\allowbreak{}Range} struct which contains the first and last
element represented by the range.

\subsubsection{PacketNumberWindow}

The \PacketNumberWindow{} class is used to test if QUIC packet the given packet number has already
been received. Internally, it contains two 64-bit fields: a bitmask marking the received bits and an
integer representing the packet number represented by the least significant bit of the mask. Marking
a packet number as received consists of setting a particular bit in the mask, shifting the other
bits if necessary. \todo{is this clear or does it need an illustration?}

The data structure can maintain state only for 64 consecutive packet numbers. This leads to packets
with packet number under the window being defensively marked as already received and, therefore,
discarded. The tollerance of the loss detection algorithm outlined in
\autoref{sec:02-loss-detection} allow way smaller packet reordering. In fact, the specification
suggests maximum reordering tollerance of 3, meaning that receiving a packet number should mark all
packets as lost except the previous two. Therefore, it is very likely that any newly received packet
with packet number under the window maintained by the \PacketNumberWindow{} instance is already
deemed lost and its data retransmitted in a different packet. Thus the width of 64 of the packet
number window is sufficient.

\todo{possibly include segmented ArrayBuffer, if I decide to implement it myself}


\section{Tests Implementation}

The QUIC implementation is covered by an extensive suite of unit tests and functional tests. The
unit tests focus on the correctness of the individual parts of the managed QUIC implementation, and
that the QUIC packets sent by the implementation conform to the QUIC protocol specification.
Functional tests, on the other hand, tests high-level functionality like being able to send and
receive data, and that the public API behavior conforms to the public API specification.

\subsection{Unit Tests}

\subsection{Functional Tests}
