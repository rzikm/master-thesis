\chapter{User Documentation}

This section provides guidance on how to obtain the build of the \dotnet{} runtime with managed QUIC
implementation, how to install it, and how to use the code to develop other applications.

\section{Getting Started}

This thesis provides a branch of the \dotnet{} runtime codebase with managed QUIC implementation.
Since our branch contains changes only in the \SystemNetQuicDll{}, the easiest way of composing a
fully working \dotnet{} distribution is obtaining a full SDK installation of the latest master
development version of \dotnet{}~6 and replacing the \SystemNetQuicDll{}. This section explains how
this can be done without affecting other \dotnet{} SDK installations present on the machine.

The managed implementation depends on a particular \libopenssl{} version in order to interoperate
with other QUIC implementations. This section also explains how to deploy a locally built
\libopenssl{} so that it is automatically used by user code. The process consists of following
steps which will be explained in following subsections:

\begin{enumerate}

  \item Build the \SystemNetQuicDll{} library from our code branch runtime.

  \item Compose a new local \dotnet{}~6 SDK installation with our \SystemNetQuicDll{}.

  \item \textit{(optional)} Compile a QUIC-supporting \libopenssl{} from source and deploy it.

  \item Configure the development environment to use the local installation when compiling the code.

\end{enumerate}

\subsection{Building the System.Net.Quic Library from Source}

The source code for the \dotnet{} runtime with managed QUIC implementation is part of this thesis'
attachments. \todo{path to the src once the attachments are finalized}. Alternatively, the code can
also be found on github \todo{link}. For the remainder of this section, all paths will be relative
to the \dotnet{} runtime repository directory.

The \dotnet{} runtime repository contains a descriptive guide on how to build the sources. The
necessary prerequisities are listed in files inside the \filename{docs/workflow/requirements/}
directory, separately for each operating system.

Once you have installed all prerequisities, you can build the entire \dotnet{} runtime using the
\filename{build.cmd} or \filename{build.sh} script:

\begin{myVerbatim}
> build.cmd -subset clr+libs -configuration release
\end{myVerbatim}

The above command will build the Common Language Runtime (CLR) and all libraries in Release
configuration. The artifacts are available in the \filename{artifacts/bin/System.Net.Quic}
directory. The important artifacts from this directory are:

\begin{itemize}

  \item \filename{ref/net6.0-Release/System.Net.Quic.dll}: The so-called reference assembly that specifies the public API of the library.

  \item \filename{net6.0-{OS}-Release/System.Net.Quic.dll}: Where \verb|{OS}| is the operating system platform you are running. This is the library with the actual implementation.

\end{itemize}

\subsection{Creating a Local Installation of \dotnet{}}\label{sec:06-local-dotnet}

Now we need to download the latest \dotnet{}~6 SDK. This zip archive containing this SDK can be
downloaded from a link listed in the official SDK installer GitHub
repository~\cite{dotnetSdkGithub}. Download the ``Master (6.0.x Runtime)'' build for your platform
and extract it to a convenient location. In the remainder of this guide, the directory containing
the extracted contents will be referred to as \filename{DOTNET_ROOT}.

The \SystemNetQuicDll{} produced in the previous subsection must be coppied to appropriate locations
in the \filename{DOTNET_ROOT}. The reference \SystemNetQuicDll{} assembly should be copied over the
existing one in the
\filename{DOTNET_ROOT/packs/Microsoft.NETCore.App.Ref/6.0.0-{version}/ref/net6.0/} directory, and
the implementation assembly to should be copied to the
\filename{DOTNET_ROOT/shared/Microsoft.NETCore.App/6.0.0-{version}/} directory, overwriting the
existing files.

\subsection{Adding the OpenSSL Library}

The implementation requires a QUIC-supporting \libopenssl{} library build from a development branch
maintained by Akamai~\cite{AkamaiOpensslGithub}. The appropriate source codes are attached
\todo{path}, or can be obtained from the github repository in branch \todo{branch name}.

Before building the source, check \filename{NOTES.{OS}} file in the repository and make sure you
have all prerequisities installed on your machine. After that, you can build the \libopenssl{}
library by running following command inside the repository. Note that for Windows OS, you must run
these commands using the \textit{Developer command prompt for Visual Studio} in order to have the necessary tools in
\texttt{PATH}.

\begin{myVerbatim}
# Windows
> perl Configure VC-WIN64A
> nmake

# Linux
> ./config
> make
\end{myVerbatim}

This will produce the \libname{libcrypto} and \libname{libssl} libraries in the \libopenssl{}
repository root. On windows, these libraries are named \texttt{libcrypto-1_1-x64.dll} and
\texttt{libssl-1_1-x64.dll}. These libraries are loaded by managed QUIC implementation at runtime
and, therefore, must be present in a location where the OS loader can find them. This can be achieved by putting the libraries in any following location:

\begin{itemize}

  \item Next to the compiled executable

  \item A directory listed in the \texttt{PATH} environment variable

  \item \textit{(preferred)} next to the \SystemNetQuicDll{} library in the \dotnet{} installation directory, i.e., \filename{DOTNET_ROOT/shared/Microsoft.NETCore.App/6.0.0-{version}/}.

\end{itemize}

\subsection{Configuring the Development Environment}\label{sec:06-env-vars}

Lastly, we need to configure the environment variables so that the \dotnet{} SDK installation created in previous step is used when building the user code. For this, following environment variables need to be defined correctly.

\begin{description}

        \ditem{\texttt{DOTNET_ROOT}} Path to the dotnet installation directory. This instructs the build process to use the SDK installed in this directory.

        \ditem{\texttt{DOTNET_MULTILEVEL_LOOKUP}} Set this to ``0''. This instructs the build process not to look for SDK installation in other places than \filename{DOTNET_ROOT}.

        \ditem{\texttt{PATH}} Prepend the \filename{DOTNET_ROOT} directory to the beginning of the \texttt{PATH} variable to make sure the \filename{dotnet} executable from the \filename{DOTNET_ROOT} is used over the system-wide installed one.
\end{description}

After configuring the variables check the output of the \verb|dotnet --info| command. Assuming
\texttt{DOTNET_ROOT} is \filename{C:\dotnet}, then the output should be similar to the
\autoref{lst:06-dotnet-info-output}. The list of installed \dotnet{} runtimes should contain
\texttt{Microsoft.NETCore.App} from the local \dotnet{}~6 SDK installation prepared in
\autoref{sec:06-local-dotnet} (check the path inside the brackets). Note that the listing contains
version numbers valid at the time of writing this text and the SDK installer would be updated since
then to a newer version.

\begin{myListingVerbatim}[Output of the \texttt{dotnet --info} command in configured environment]{lst:06-dotnet-info-output}{Output of the \texttt{dotnet --info} command in correctly configured environment. The unimportant portions of the output in grey has been left out brevity}
> dotnet --info
&color{colorunimportant}.NET SDK (reflecting any global.json):
&color{colorunimportant} ...

&color{colorunimportant}Runtime Environment:
&color{colorunimportant} ...

&color{colorunimportant}Host (useful for support):
&color{colorunimportant} ...

.NET SDKs installed:
  6.0.100-alpha.1.20563.2 [&textbf{C:\dotnet\sdk}]

.NET runtimes installed:
  Microsoft.AspNetCore.App 6.0.0-alpha.1.20526.6 [&textbf{C:\dotnet\shared\}&textcolor{colorunimportant}{...}]
  Microsoft.NETCore.App 6.0.0-alpha.1.20560.10 [&textbf{C:\dotnet\shared\}&textcolor{colorunimportant}{...}]
  Microsoft.WindowsDesktop.App 6.0.0-alpha.1.20560.7 [&textbf{C:\dotnet\shared\}&textcolor{colorunimportant}{...}]

&color{colorunimportant}To install additional .NET runtimes or SDKs:
&color{colorunimportant}  https://aka.ms/dotnet-download
\end{myListingVerbatim}

With environment configured as described, you can now use the
\verb|dotnet build| command, or start Visual Studio or other IDE to develop programs using the
provided SDK installation.

\subsection{Creating a Sample \dotnet{}~6 Project}

The last step is creating a new project and configuring it to use \dotnet{}~6. This section
demonstrates how this can be done using the \verb|dotnet| command line tool. Assuming the
environment variables have been configured as specified in \autoref{sec:06-env-vars}, you can create
a new project using the following commands:

\begin{myVerbatim}
> mkdir hello-net6
> cd hello-net6
> dotnet new console
\end{myVerbatim}

These commands will create a \filename{hello-net6/hello-net6.csproj} file. Use of \dotnet{}~6
preview requires minor changes to the project file. Namely changing the \xmltag{TargetFramework}
property to \verb|net6.0|. The modified project file contents are listed in \autoref{lst:06-csproj-net6.0}.

\begin{myListingXml}{lst:06-csproj-net6.0}{Project file for \dotnet{}~6 console application project.}{Sdk}
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net6.0</TargetFramework>
    <RootNamespace>hello_net6</RootNamespace>
  </PropertyGroup>

</Project>
\end{myListingXml}

Lastly, the NuGet package feed must be configured to use the correct source for the preview packages
for \dotnet{}~6. This can be done by creating a \filename{NuGet.Config} file in the project
directory with contents as listed in \autoref{lst:06-nuget-config}. The contents can be also copied
from the webpage from which the \dotnet{}~6 SDK was downloaded.

\begin{myListingXml}[basicstyle=\ttfamily\scriptsize]{lst:06-nuget-config}{NuGet configuration file for \dotnet{}~6 projects.}{key,value}
<configuration>
  <packageSources>
    <add key="dotnet6"
      value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet6/nuget/v3/index.json" />
  </packageSources>
</configuration>
\end{myListingXml}

To demonstrate that we are using the correct SDK, you can try compiling and running program from
\autoref{lst:06-hello-net6}.

\begin{myListingCsharp}{lst:06-hello-net6}{\csharp{} program for testing the SDK installation.}{Program,FileVersionInfo,Console,Path}{}
using System;
using System.Diagnostics;

namespace hello_net6._0
{
    class Program
    {
        static void |Main|(string[] args)
        {
            string assemblyPath = typeof(object).Assembly.Location;
            string assemblyDir = Path.|GetDirectoryName|(assemblyPath);
            var info = FileVersionInfo.|GetVersionInfo|(assemblyPath);
            Console.|WriteLine|($"Hello from .NET {info.ProductVersion}");
            Console.|WriteLine|($"Runtime location: {assemblyDir}");
        }
    }
}
\end{myListingCsharp}

Running the program should produce similar output to the following:

\begin{myVerbatim}
> dotnet run
Hello from .NET 6.0.0-alpha.1.20560.10+72b7d236ad634c2280c73499ebfc2b594995ec06
Runtime location: C:\dotnet\shared\Microsoft.NETCore.App\6.0.0-alpha.1.20560.10
\end{myVerbatim}

\section{Using QUIC in \dotnet{}}

This section is a walkthrough on how to use QUIC in \dotnet{}. In this section, we will create a
trivial echo server. When a new connection is established, clients will open a single bidirectional
stream and send arbitrary data over it. The server will then echo the data back to the client. For
simplicity, We will use a single \dotnet{} program to represent both client and server and conduct
the connection over the loopback network interface.

\subsection{Echo Server Implementation}

Use of TLS 1.3 for encryption is mandatory for QUIC. This requires providing an X.509 certificate on
the server side. The current QUIC API requires that the certificate and the private key be saved in
separate files. A certificate that can be used in this example is provided in the attachments
\todo{path in the attachments}. \todo{creating a new ssl certificate using openssl cli?}

In order to accept incoming QUIC connections, we need to create an instance of \QuicListener{}.
\autoref{lst:06-echo-quic-listener} shows how the \QuicListener{} can be created and provided with:

\begin{itemize}

  \item listening endpoint,

  \item \texttt{"echo"} identifier of the application-layer protocol to use in \gls{alpn}, and

  \item paths to the X.509 certificate and private key file.

\end{itemize}

The \QuicListener{} class implements \interface{IDisposable} and, therefore, we can also use
\keyword{using} statement to make sure the \QuicListener{} is closed when the method returns.

\begin{myListingCsharp}{lst:06-echo-quic-listener}{Creating and starting a new \QuicListener{} for the echo server}{Task,QuicListener,QuicListenerOptions,SslServerAuthenticationOptions,List,SslApplicationProtocol,IPEndPoint,CancellationToken}{}
public static async Task<int> |RunServer|(IPEndPoint listenEp,
    string certificateFile, string privateKeyFile, CancellationToken token)
{
    using QuicListener listener = new QuicListener(new QuicListenerOptions
    {
        ListenEndPoint = listenEp,
        CertificateFilePath = certificateFile,
        PrivateKeyFilePath = privateKeyFile,
        ServerAuthenticationOptions = new SslServerAuthenticationOptions
        {
            ApplicationProtocols = new List<SslApplicationProtocol>
            {
                new SslApplicationProtocol("echo")
            }
        }
    });

    // ...
}
\end{myListingCsharp}

We can then use the \method{AcceptConnectionAsync} method to asynchronously wait for new incoming connections. \autoref{lst:06-echo-server-accept} shows how

\begin{myListingCsharp}{lst:06-echo-server-accept}{Accepting new connections on \QuicListener{}}{List,Task,QuicConnection}{}
    // QuicListener must be started before accepting connections.
    listener.|Start|();

    // tasks that need to be awaited when trying to exit gracefully
    List<Task> tasks = new List<Task>();

    try
    {
        QuicConnection conn;
        while ((conn = await listener.|AcceptConnectionAsync|(token)) != null)
        {
            // copy the connection into a variable with narrower scope so
            //that it is not shared among multiple lambdas
            QuicConnection captured = conn;
            var task = Task.|Run|(
                () => |HandleServerConnection|(captured, token));
            tasks.|Add|(task);
        }
    }
    finally
    {
        // wait until all connections are closed
        await Task.|WhenAll|(tasks);
    }
\end{myListingCsharp}

\autoref{lst:06-echo-server-loop} Shows the implementation of \method{HandleServerConnection} which
does the actual echoing of incoming data. The \QuicStream{} is accepted using the
\method{AcceptStreamAsync} method on the \QuicConnection{} class and, because it is a bidirectional
stream, we can use it to send the data back to the clien. Lastly, once all data is sent, we
gracefully close the connection using the \method{CloseAsync} method.

\begin{myListingCsharp}{lst:06-echo-server-loop}{Echo server reading and writing data to \QuicStream{}}{Task,QuicConnection,CancellationToken,QuicStream}{}
public static async Task |HandleServerConnection|(QuicConnection connection,
    CancellationToken token)
{
    try
    {
        QuicStream stream = await connection.|AcceptStreamAsync|(token);

        byte[] buffer = new byte[4 * 1024];

        int read;
        while ((read = await stream.|ReadAsync|(buffer, token)) > 0)
        {
            await stream.|WriteAsync|(buffer, 0, read, token);
            await stream.|FlushAsync|(token);
        }
    }
    finally
    {
        // gracefully close the connection with 0 error code
        await connection.|CloseAsync|(0);
    }
}
\end{myListingCsharp}

\subsection{Echo Client Implementation}

The client implementation is more straightforward than that of the server.
\autoref{lst:06-echo-client-connection} shows how to create a client \QuicConnection{} using the
using the server endpoint address and the \gls{alpn} identifier. The connection can be then
established by calling the \method{ConnectAsync} method.

\begin{myListingCsharpNoPageBreak}{lst:06-echo-client-connection}{Creating a client \QuicConnection{} instance}{Task,IPEndPoint,CancellationToken,QuicConnection,QuicClientConnectionOptions,SslClientAuthenticationOptions,List,SslApplicationProtocol}{}
public static async Task<int> |RunClient|(IPEndPoint serverEp,
    CancellationToken token)
{
    using var client = new QuicConnection(new QuicClientConnectionOptions
    {
        RemoteEndPoint = serverEp,
        ClientAuthenticationOptions = new SslClientAuthenticationOptions
        {
            ApplicationProtocols = new List<SslApplicationProtocol>
            {
                new SslApplicationProtocol("echo")
            }
        }
    });

    await client.|ConnectAsync|(token);

    // ...
}
\end{myListingCsharpNoPageBreak}

Once the connection is established, the client opens a bidirectional \QuicStream{} using the
\method{OpenBidirectionalStream} method. The \QuicStream{} can be used like any other \Stream{}
instance. \autoref{lst:06-echo-client-loop} shows the rest of the echo client implementation.

\begin{myListingCsharp}{lst:06-echo-client-loop}{Sending standard input via \QuicStream{}}{QuicStream,Task,Encoding,Console}{}
    try
    {
        await using QuicStream stream = client.|OpenBidirectionalStream|();

        // spawn a reader task to not let server be flow-control blocked
        _ = Task.|Run|(async () =>
        {
            byte[] arr = new byte[4 * 1024];
            int read;
            while ((read = await stream.|ReadAsync|(arr, token)) > 0)
            {
                string s = Encoding.ASCII.|GetString|(arr, 0, read);
                Console.|WriteLine|($"Received: {s}");
            }
        });

        string line;
        while ((line = Console.|ReadLine|()) != null)
        {
            // convert into ASCII byte array before sending
            byte[] bytes = Encoding.ASCII.|GetBytes|(line);
            await stream.|WriteAsync|(bytes, token);
            // flush the stream to send the data immediately
            await stream.|FlushAsync|();
        }

        // once all stdin is written, close the stream
        stream.|Shutdown|();

        // wait until the server receives all data
        await stream.|ShutdownWriteCompleted|(token);
    }
    finally
    {
        // gracefully close the connection with 0 error code
        await client.|CloseAsync|(0, token);
    }
\end{myListingCsharp}

\section{A More Complex Example Application}

\todo{deeper explanation of the example throughput testing application that was used in Evaluation}

\section{QUIC API Reference}\label{sec:06-api}

This section describes the API that was designed by the \dotnet{} development team to expose QUIC to
other developers. This thesis will use this API to allow swapping underlying implementation between
this thesis implementation and the \libmsquic{}-based implementation. As mentioned in the
introduction chapter, the current design is a work-in-progress and is subject to change in the
future. All of the mentioned classes are located in the \namespace{System.Net.Quic} namespace.

\subsection{QuicListener Class}

The \class{QuicListener} class is the equivalent of the \class{TcpListener}. Servers use this
class to accept incoming QUIC connections.

\begin{description}

    \ditemctor{QuicListener}{\QuicListenerOptions{}} Constructor.

    \ditemproperty{IPEndPoint}{ListenEndPoint}{\propget} The IP endpoint being listened to for new connection. Read-only.

    \ditemmethod[]{\ValueTaskOf{\QuicConnection{}}}{AcceptConnectionAsync}{\CancellationToken{}}
    Accepts a new incoming QUIC Connection.

    \ditemmethod[\keyword]{void}{Start}{} Starts listening.

    \ditemmethod[\keyword]{void}{Close}{} Stops listening and closes the listener. Does not close already accepted connections.

\end{description}

\subsection{QuicListenerOptions Class}

The \class{QuicListenerOptions} class holds all configuration used to construct new \class{QuicListener} instances.

\begin{description}

    \ditemproperty{SslServerAuthenticationOptions}{\ServerAuthenticationOptions{}}{\propgetset}
        SSL related options like certificate selection/validation callbacks, and supported protocols for ALPN\@.

    \ditemproperty[\keyword]{string}{CertificateFilePath}{\propgetset} Path to the X.509 certificate used by the server.

    \ditemproperty[\keyword]{string}{CertificateKeyPath}{\propgetset} Path to the private key for the used X.509 certificate.

    \ditemproperty[\keyword]{string}{CertificateKeyPath}{\propgetset} Path to the private key for the used X.509 certificate.

    \ditemproperty{IPEndPoint}{ListenEndPoint}{\propgetset} The IP endpoint to listen on.

    \ditemproperty[\keyword]{int}{ListenBacklog}{\propgetset} Number of connection to be held waiting for acceptance by the application. Upon reaching this limit, further connections will be refused.

    \ditemproperty[\keyword]{long}{MaxBidirectionalStreams}{\propgetset} Limit on the number of bidirectional streams the client can open in an accepted connection.

    \ditemproperty[\keyword]{long}{MaxUnidirectionalStreams}{\propgetset} Limit on the number of unidirectional streams the client can open in an accepted connection.

    \ditemproperty{TimeSpan}{IdleTimeout}{\propgetset} The period of inactivity after which the connection will be closed via idle timeout.

\end{description}

\subsection{QuicConnection Class}

The \QuicConnection{} class provides operation on the QUIC connection. Clients open new
connections by creating a new instance of this class and calling the \method{ConnectAsync} method.
Servers receive new connections using the \class{QuicListener} class.

\begin{description}

    \ditemctor{QuicConnection}{\QuicClientConnectionOptions{}} Constructor. The newly created instance is not connected until the call to \method{ConnectAsync} method.

    \ditemproperty[\keyword]{bool}{Connected}{\propget} Indicates whether the \QuicConnection{} is connected (the handshake has completed).

    \ditemproperty{IPEndPoint}{LocalEndPoint}{\propget} Local IP endpoint of the connection.

    \ditemproperty{IPEndPoint}{RemoteEndPoint}{\propget} Remote IP endpoint of the connection.

    \ditemmethod{ValueTask}{ConnectAsync}{\CancellationToken{}} Connects to the remote endpoint.

    \ditemmethod{QuicStream}{OpenUnidirectionalStream}{} Opens a new unidirectional stream. Throws a \class{QuicException} if the stream cannot be opened.

    \ditemmethod{QuicStream}{OpenBidirectionalStream}{} Opens a new bidirectional stream. Throws a \class{QuicException} if the stream cannot be opened.

    \ditemmethod[]{\ValueTaskOf{\QuicStream{}}}{AcceptStreamAsync}{\CancellationToken{}} Accepts an incoming stream.

    \ditemmethod{ValueTask}{CloseAsync}{\Long{}, \CancellationToken{}} Closes the connection with the specified given error code and terminates all active streams.

    \ditemmethod[\keyword]{long}{GetRemoteAvailableUnidirectionalStreamCount}{} Gets the maximum number of unidirectional streams that this endpoint can open.

    \ditemmethod[\keyword]{long}{GetRemoteAvailableBidirectionalStreamCount}{} Gets the maximum number of bidirectional streams that this endpoint can open.

\end{description}

\subsection{QuicClientConnectionOptions}

The \class{QuicClientConnectionOptions} is used by clients to configure new QUIC conections.

\begin{description}

    \ditemproperty{SslClientAuthenticationOptions}{ClientAuthenticationOptions}{\propgetset} Client authentication options to use when establishing the connection.

    \ditemproperty{IPEndPoint}{LocalEndPoint}{\propgetset} The local IP endpoint that will be bound to.

    \ditemproperty{IPEndPoint}{RemoteEndPoint}{\propgetset} The IP endpoint to connect to.

    \ditemproperty[\keyword]{long}{MaxBidirectionalStreams}{\propgetset} Limit on the number of bidirectional streams the server can open.

    \ditemproperty[\keyword]{long}{MaxUnidirectionalStreams}{\propgetset} Limit on the number of unidirectional streams the server can open.

    \ditemproperty{TimeSpan}{IdleTimeout}{\propgetset} The period of inactivity after which the connection will be closed via idle timeout.

\end{description}

\subsection{QuicStream Class}

The \QuicStream{} class represents a single stream in a QUIC connection and derives from the
abstract \class{Stream} class. The \class{Stream} class is a bidirectional stream abstraction and
since not all QUIC streams are bidirectional, user should check if the specific \QuicStream{}
instance supports supports the operation by inspecting the \method{CanRead} and \method{CanWrite}
properties. Invoking read methods on write-only (i.e. unidirectional sending) stream will cause an
exception to be thrown and vice versa.

The list below mentions the members specific for the \class{QuicStream} class and some important
members inherited from the \class{Stream} class.

\begin{description}

    \ditemproperty[\keyword]{long}{StreamId}{\propget} The Stream ID\@.

    \ditemproperty[\keyword]{bool}{CanRead}{\propget} Returns \keyword{true} if the stream supports reading.

    \ditemproperty[\keyword]{bool}{CanWrite}{\propget} Returns \keyword{true} if the stream supports reading.

    \ditemmethod[\keyword]{void}{AbortRead}{\Long} Aborts the receiving part of the stream with the provided error code.

    \ditemmethod[\keyword]{void}{AbortWrite}{\Long} Aborts the sending part of the stream with the provided error code.

    \ditemmethod[\keyword]{int}{Read}{\SpanOf{\byte{}}} Reads the content
    of the stream into the provided buffer, blocks if no data is available. Returns 0 only when there will be no more data in the stream.

    \ditemmethod[]{\ValueTaskOf{\keyword{int}}}{ReadAsync}{\MemoryOf{\byte{}}, \CancellationToken{}} Reads the content
    of the stream into provided buffer, blocks until some data is available. Returns 0 only when there will be no more data in the stream.

    \ditemmethod[\keyword]{void}{Write}{\SpanOf{\byte}} Writes the content
    of the provided buffer into the stream, returns when the data have been buffered internally.

    \ditemmethodWithComment{ValueTask}{WriteAsync}{*, \CancellationToken{}}{multiple overloads} Multiple overloads of this method offer writing from various types of buffers: \ReadOnlyMemoryOf{\byte{}}, \ReadOnlySequenceOf{\byte{}}, and \genericClass{ReadOnlyMemory\allowbreak{}}{\ReadOnlyMemoryOf{\byte{}}}. The last one can be used to perform scatter/gather IO. The returned task completes when the provided data have been buffered internally and the buffers can be reused for other purposes.

    \ditemmethodWithComment{ValueTask}{WriteAsync}{*, \bool{}, \CancellationToken{}}{multiple overloads} Like the methods above, but also allow specifying that the provided data are the last on the stream and that the stream should be gracefully closed.

    \ditemmethod{ValueTask}{ShutdownWriteCompleted}{\CancellationToken{}} The returned task completes when the stream shutdown completes. Meaning that acknowledgement from the peer is received.

    \ditemmethod{ValueTask}{Shutdown}{} Closes the stream with error code 0. And blocks until shutdown completes.

\end{description}

\subsection{Exceptions}

The QUIC API can throw following exceptions:

\begin{description}

    \ditem{\ditemsrcsize\class{QuicException}} Base class for all thrown exceptions, used when a more specific exception is not available

    \ditem{\ditemsrcsize\class{QuicConnectionAbortedException}} Thrown when the connection is forcibly closed either by the transport or by the remote endpoint.

    \ditem{\ditemsrcsize\class{QuicStreamAbortedException}} Thrown when the stream was aborted by the remote endpoint.

    \ditem{\ditemsrcsize\class{QuicOperationAbortedException}} Thrown when the pending operation was aborted by the local endpoint.

\end{description}
